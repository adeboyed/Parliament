// This file is generated by rust-protobuf 2.0.5. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct DataRetrievalRequest {
    // message fields
    pub user_id: ::std::string::String,
    pub job_id: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DataRetrievalRequest {
    pub fn new() -> DataRetrievalRequest {
        ::std::default::Default::default()
    }

    // string user_id = 1;

    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }

    // int32 job_id = 2;

    pub fn clear_job_id(&mut self) {
        self.job_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_job_id(&mut self, v: i32) {
        self.job_id = v;
    }

    pub fn get_job_id(&self) -> i32 {
        self.job_id
    }
}

impl ::protobuf::Message for DataRetrievalRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.job_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user_id);
        }
        if self.job_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.job_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.user_id.is_empty() {
            os.write_string(1, &self.user_id)?;
        }
        if self.job_id != 0 {
            os.write_int32(2, self.job_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataRetrievalRequest {
        DataRetrievalRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_id",
                    |m: &DataRetrievalRequest| { &m.user_id },
                    |m: &mut DataRetrievalRequest| { &mut m.user_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "job_id",
                    |m: &DataRetrievalRequest| { &m.job_id },
                    |m: &mut DataRetrievalRequest| { &mut m.job_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DataRetrievalRequest>(
                    "DataRetrievalRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DataRetrievalRequest {
        static mut instance: ::protobuf::lazy::Lazy<DataRetrievalRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DataRetrievalRequest,
        };
        unsafe {
            instance.get(DataRetrievalRequest::new)
        }
    }
}

impl ::protobuf::Clear for DataRetrievalRequest {
    fn clear(&mut self) {
        self.clear_user_id();
        self.clear_job_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataRetrievalRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataRetrievalRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DataRetrievalResponse {
    // message fields
    pub bytes: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DataRetrievalResponse {
    pub fn new() -> DataRetrievalResponse {
        ::std::default::Default::default()
    }

    // bytes bytes = 1;

    pub fn clear_bytes(&mut self) {
        self.bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.bytes
    }

    // Take field
    pub fn take_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.bytes, ::std::vec::Vec::new())
    }

    pub fn get_bytes(&self) -> &[u8] {
        &self.bytes
    }
}

impl ::protobuf::Message for DataRetrievalResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.bytes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.bytes.is_empty() {
            os.write_bytes(1, &self.bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DataRetrievalResponse {
        DataRetrievalResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "bytes",
                    |m: &DataRetrievalResponse| { &m.bytes },
                    |m: &mut DataRetrievalResponse| { &mut m.bytes },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DataRetrievalResponse>(
                    "DataRetrievalResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DataRetrievalResponse {
        static mut instance: ::protobuf::lazy::Lazy<DataRetrievalResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DataRetrievalResponse,
        };
        unsafe {
            instance.get(DataRetrievalResponse::new)
        }
    }
}

impl ::protobuf::Clear for DataRetrievalResponse {
    fn clear(&mut self) {
        self.clear_bytes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DataRetrievalResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataRetrievalResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InputAction {
    // message fields
    pub data_loc_in: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl InputAction {
    pub fn new() -> InputAction {
        ::std::default::Default::default()
    }

    // bytes data_loc_in = 1;

    pub fn clear_data_loc_in(&mut self) {
        self.data_loc_in.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_loc_in(&mut self, v: ::std::vec::Vec<u8>) {
        self.data_loc_in = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_loc_in(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data_loc_in
    }

    // Take field
    pub fn take_data_loc_in(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data_loc_in, ::std::vec::Vec::new())
    }

    pub fn get_data_loc_in(&self) -> &[u8] {
        &self.data_loc_in
    }
}

impl ::protobuf::Message for InputAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data_loc_in)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data_loc_in.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data_loc_in);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.data_loc_in.is_empty() {
            os.write_bytes(1, &self.data_loc_in)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InputAction {
        InputAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data_loc_in",
                    |m: &InputAction| { &m.data_loc_in },
                    |m: &mut InputAction| { &mut m.data_loc_in },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InputAction>(
                    "InputAction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InputAction {
        static mut instance: ::protobuf::lazy::Lazy<InputAction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const InputAction,
        };
        unsafe {
            instance.get(InputAction::new)
        }
    }
}

impl ::protobuf::Clear for InputAction {
    fn clear(&mut self) {
        self.clear_data_loc_in();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InputAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MapAction {
    // message fields
    pub mapType: MapAction_MapType,
    pub job_id_in: i32,
    pub function_closure: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl MapAction {
    pub fn new() -> MapAction {
        ::std::default::Default::default()
    }

    // .MapAction.MapType mapType = 1;

    pub fn clear_mapType(&mut self) {
        self.mapType = MapAction_MapType::SINGLE_IN_MULTI_OUT;
    }

    // Param is passed by value, moved
    pub fn set_mapType(&mut self, v: MapAction_MapType) {
        self.mapType = v;
    }

    pub fn get_mapType(&self) -> MapAction_MapType {
        self.mapType
    }

    // int32 job_id_in = 2;

    pub fn clear_job_id_in(&mut self) {
        self.job_id_in = 0;
    }

    // Param is passed by value, moved
    pub fn set_job_id_in(&mut self, v: i32) {
        self.job_id_in = v;
    }

    pub fn get_job_id_in(&self) -> i32 {
        self.job_id_in
    }

    // bytes function_closure = 3;

    pub fn clear_function_closure(&mut self) {
        self.function_closure.clear();
    }

    // Param is passed by value, moved
    pub fn set_function_closure(&mut self, v: ::std::vec::Vec<u8>) {
        self.function_closure = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function_closure(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.function_closure
    }

    // Take field
    pub fn take_function_closure(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.function_closure, ::std::vec::Vec::new())
    }

    pub fn get_function_closure(&self) -> &[u8] {
        &self.function_closure
    }
}

impl ::protobuf::Message for MapAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mapType, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.job_id_in = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.function_closure)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mapType != MapAction_MapType::SINGLE_IN_MULTI_OUT {
            my_size += ::protobuf::rt::enum_size(1, self.mapType);
        }
        if self.job_id_in != 0 {
            my_size += ::protobuf::rt::value_size(2, self.job_id_in, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.function_closure.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.function_closure);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.mapType != MapAction_MapType::SINGLE_IN_MULTI_OUT {
            os.write_enum(1, self.mapType.value())?;
        }
        if self.job_id_in != 0 {
            os.write_int32(2, self.job_id_in)?;
        }
        if !self.function_closure.is_empty() {
            os.write_bytes(3, &self.function_closure)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MapAction {
        MapAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MapAction_MapType>>(
                    "mapType",
                    |m: &MapAction| { &m.mapType },
                    |m: &mut MapAction| { &mut m.mapType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "job_id_in",
                    |m: &MapAction| { &m.job_id_in },
                    |m: &mut MapAction| { &mut m.job_id_in },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "function_closure",
                    |m: &MapAction| { &m.function_closure },
                    |m: &mut MapAction| { &mut m.function_closure },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MapAction>(
                    "MapAction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MapAction {
        static mut instance: ::protobuf::lazy::Lazy<MapAction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MapAction,
        };
        unsafe {
            instance.get(MapAction::new)
        }
    }
}

impl ::protobuf::Clear for MapAction {
    fn clear(&mut self) {
        self.clear_mapType();
        self.clear_job_id_in();
        self.clear_function_closure();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MapAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MapAction_MapType {
    SINGLE_IN_MULTI_OUT = 0,
    SINGLE_IN_SINGLE_OUT = 1,
    MULTI_IN_SINGLE_OUT = 2,
}

impl ::protobuf::ProtobufEnum for MapAction_MapType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MapAction_MapType> {
        match value {
            0 => ::std::option::Option::Some(MapAction_MapType::SINGLE_IN_MULTI_OUT),
            1 => ::std::option::Option::Some(MapAction_MapType::SINGLE_IN_SINGLE_OUT),
            2 => ::std::option::Option::Some(MapAction_MapType::MULTI_IN_SINGLE_OUT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MapAction_MapType] = &[
            MapAction_MapType::SINGLE_IN_MULTI_OUT,
            MapAction_MapType::SINGLE_IN_SINGLE_OUT,
            MapAction_MapType::MULTI_IN_SINGLE_OUT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MapAction_MapType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MapAction_MapType {
}

impl ::std::default::Default for MapAction_MapType {
    fn default() -> Self {
        MapAction_MapType::SINGLE_IN_MULTI_OUT
    }
}

impl ::protobuf::reflect::ProtobufValue for MapAction_MapType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Job {
    // message fields
    pub job_id: i32,
    // message oneof groups
    pub action: ::std::option::Option<Job_oneof_action>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Job_oneof_action {
    input(InputAction),
    map(MapAction),
}

impl Job {
    pub fn new() -> Job {
        ::std::default::Default::default()
    }

    // int32 job_id = 1;

    pub fn clear_job_id(&mut self) {
        self.job_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_job_id(&mut self, v: i32) {
        self.job_id = v;
    }

    pub fn get_job_id(&self) -> i32 {
        self.job_id
    }

    // .InputAction input = 4;

    pub fn clear_input(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_input(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Job_oneof_action::input(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: InputAction) {
        self.action = ::std::option::Option::Some(Job_oneof_action::input(v))
    }

    // Mutable pointer to the field.
    pub fn mut_input(&mut self) -> &mut InputAction {
        if let ::std::option::Option::Some(Job_oneof_action::input(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Job_oneof_action::input(InputAction::new()));
        }
        match self.action {
            ::std::option::Option::Some(Job_oneof_action::input(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_input(&mut self) -> InputAction {
        if self.has_input() {
            match self.action.take() {
                ::std::option::Option::Some(Job_oneof_action::input(v)) => v,
                _ => panic!(),
            }
        } else {
            InputAction::new()
        }
    }

    pub fn get_input(&self) -> &InputAction {
        match self.action {
            ::std::option::Option::Some(Job_oneof_action::input(ref v)) => v,
            _ => InputAction::default_instance(),
        }
    }

    // .MapAction map = 5;

    pub fn clear_map(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_map(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Job_oneof_action::map(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: MapAction) {
        self.action = ::std::option::Option::Some(Job_oneof_action::map(v))
    }

    // Mutable pointer to the field.
    pub fn mut_map(&mut self) -> &mut MapAction {
        if let ::std::option::Option::Some(Job_oneof_action::map(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Job_oneof_action::map(MapAction::new()));
        }
        match self.action {
            ::std::option::Option::Some(Job_oneof_action::map(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_map(&mut self) -> MapAction {
        if self.has_map() {
            match self.action.take() {
                ::std::option::Option::Some(Job_oneof_action::map(v)) => v,
                _ => panic!(),
            }
        } else {
            MapAction::new()
        }
    }

    pub fn get_map(&self) -> &MapAction {
        match self.action {
            ::std::option::Option::Some(Job_oneof_action::map(ref v)) => v,
            _ => MapAction::default_instance(),
        }
    }
}

impl ::protobuf::Message for Job {
    fn is_initialized(&self) -> bool {
        if let Some(Job_oneof_action::input(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Job_oneof_action::map(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.job_id = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Job_oneof_action::input(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Job_oneof_action::map(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.job_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.job_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &Job_oneof_action::input(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Job_oneof_action::map(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.job_id != 0 {
            os.write_int32(1, self.job_id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &Job_oneof_action::input(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Job_oneof_action::map(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Job {
        Job::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "job_id",
                    |m: &Job| { &m.job_id },
                    |m: &mut Job| { &mut m.job_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, InputAction>(
                    "input",
                    Job::has_input,
                    Job::get_input,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MapAction>(
                    "map",
                    Job::has_map,
                    Job::get_map,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Job>(
                    "Job",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Job {
        static mut instance: ::protobuf::lazy::Lazy<Job> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Job,
        };
        unsafe {
            instance.get(Job::new)
        }
    }
}

impl ::protobuf::Clear for Job {
    fn clear(&mut self) {
        self.clear_job_id();
        self.clear_input();
        self.clear_map();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Job {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Job {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JobSubmission {
    // message fields
    pub user_id: ::std::string::String,
    pub jobs: ::protobuf::RepeatedField<Job>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl JobSubmission {
    pub fn new() -> JobSubmission {
        ::std::default::Default::default()
    }

    // string user_id = 1;

    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }

    // repeated .Job jobs = 2;

    pub fn clear_jobs(&mut self) {
        self.jobs.clear();
    }

    // Param is passed by value, moved
    pub fn set_jobs(&mut self, v: ::protobuf::RepeatedField<Job>) {
        self.jobs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_jobs(&mut self) -> &mut ::protobuf::RepeatedField<Job> {
        &mut self.jobs
    }

    // Take field
    pub fn take_jobs(&mut self) -> ::protobuf::RepeatedField<Job> {
        ::std::mem::replace(&mut self.jobs, ::protobuf::RepeatedField::new())
    }

    pub fn get_jobs(&self) -> &[Job] {
        &self.jobs
    }
}

impl ::protobuf::Message for JobSubmission {
    fn is_initialized(&self) -> bool {
        for v in &self.jobs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.jobs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user_id);
        }
        for value in &self.jobs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.user_id.is_empty() {
            os.write_string(1, &self.user_id)?;
        }
        for v in &self.jobs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JobSubmission {
        JobSubmission::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_id",
                    |m: &JobSubmission| { &m.user_id },
                    |m: &mut JobSubmission| { &mut m.user_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Job>>(
                    "jobs",
                    |m: &JobSubmission| { &m.jobs },
                    |m: &mut JobSubmission| { &mut m.jobs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<JobSubmission>(
                    "JobSubmission",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static JobSubmission {
        static mut instance: ::protobuf::lazy::Lazy<JobSubmission> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const JobSubmission,
        };
        unsafe {
            instance.get(JobSubmission::new)
        }
    }
}

impl ::protobuf::Clear for JobSubmission {
    fn clear(&mut self) {
        self.clear_user_id();
        self.clear_jobs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JobSubmission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JobSubmission {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JobSubmissionResponse {
    // message fields
    pub job_accepted: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl JobSubmissionResponse {
    pub fn new() -> JobSubmissionResponse {
        ::std::default::Default::default()
    }

    // bool job_accepted = 1;

    pub fn clear_job_accepted(&mut self) {
        self.job_accepted = false;
    }

    // Param is passed by value, moved
    pub fn set_job_accepted(&mut self, v: bool) {
        self.job_accepted = v;
    }

    pub fn get_job_accepted(&self) -> bool {
        self.job_accepted
    }
}

impl ::protobuf::Message for JobSubmissionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.job_accepted = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.job_accepted != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.job_accepted != false {
            os.write_bool(1, self.job_accepted)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JobSubmissionResponse {
        JobSubmissionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "job_accepted",
                    |m: &JobSubmissionResponse| { &m.job_accepted },
                    |m: &mut JobSubmissionResponse| { &mut m.job_accepted },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<JobSubmissionResponse>(
                    "JobSubmissionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static JobSubmissionResponse {
        static mut instance: ::protobuf::lazy::Lazy<JobSubmissionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const JobSubmissionResponse,
        };
        unsafe {
            instance.get(JobSubmissionResponse::new)
        }
    }
}

impl ::protobuf::Clear for JobSubmissionResponse {
    fn clear(&mut self) {
        self.clear_job_accepted();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JobSubmissionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JobSubmissionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateConnectionRequest {
    // message fields
    pub authentication: ::std::string::String,
    pub docker_name: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl CreateConnectionRequest {
    pub fn new() -> CreateConnectionRequest {
        ::std::default::Default::default()
    }

    // string authentication = 1;

    pub fn clear_authentication(&mut self) {
        self.authentication.clear();
    }

    // Param is passed by value, moved
    pub fn set_authentication(&mut self, v: ::std::string::String) {
        self.authentication = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authentication(&mut self) -> &mut ::std::string::String {
        &mut self.authentication
    }

    // Take field
    pub fn take_authentication(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.authentication, ::std::string::String::new())
    }

    pub fn get_authentication(&self) -> &str {
        &self.authentication
    }

    // string docker_name = 2;

    pub fn clear_docker_name(&mut self) {
        self.docker_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_docker_name(&mut self, v: ::std::string::String) {
        self.docker_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_docker_name(&mut self) -> &mut ::std::string::String {
        &mut self.docker_name
    }

    // Take field
    pub fn take_docker_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.docker_name, ::std::string::String::new())
    }

    pub fn get_docker_name(&self) -> &str {
        &self.docker_name
    }
}

impl ::protobuf::Message for CreateConnectionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.authentication)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.docker_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.authentication.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.authentication);
        }
        if !self.docker_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.docker_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.authentication.is_empty() {
            os.write_string(1, &self.authentication)?;
        }
        if !self.docker_name.is_empty() {
            os.write_string(2, &self.docker_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateConnectionRequest {
        CreateConnectionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "authentication",
                    |m: &CreateConnectionRequest| { &m.authentication },
                    |m: &mut CreateConnectionRequest| { &mut m.authentication },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "docker_name",
                    |m: &CreateConnectionRequest| { &m.docker_name },
                    |m: &mut CreateConnectionRequest| { &mut m.docker_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateConnectionRequest>(
                    "CreateConnectionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateConnectionRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateConnectionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateConnectionRequest,
        };
        unsafe {
            instance.get(CreateConnectionRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateConnectionRequest {
    fn clear(&mut self) {
        self.clear_authentication();
        self.clear_docker_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateConnectionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateConnectionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateConnectionResponse {
    // message fields
    pub user_id: ::std::string::String,
    pub connection_accepted: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl CreateConnectionResponse {
    pub fn new() -> CreateConnectionResponse {
        ::std::default::Default::default()
    }

    // string user_id = 1;

    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }

    // bool connection_accepted = 2;

    pub fn clear_connection_accepted(&mut self) {
        self.connection_accepted = false;
    }

    // Param is passed by value, moved
    pub fn set_connection_accepted(&mut self, v: bool) {
        self.connection_accepted = v;
    }

    pub fn get_connection_accepted(&self) -> bool {
        self.connection_accepted
    }
}

impl ::protobuf::Message for CreateConnectionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.connection_accepted = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user_id);
        }
        if self.connection_accepted != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.user_id.is_empty() {
            os.write_string(1, &self.user_id)?;
        }
        if self.connection_accepted != false {
            os.write_bool(2, self.connection_accepted)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateConnectionResponse {
        CreateConnectionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_id",
                    |m: &CreateConnectionResponse| { &m.user_id },
                    |m: &mut CreateConnectionResponse| { &mut m.user_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "connection_accepted",
                    |m: &CreateConnectionResponse| { &m.connection_accepted },
                    |m: &mut CreateConnectionResponse| { &mut m.connection_accepted },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateConnectionResponse>(
                    "CreateConnectionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateConnectionResponse {
        static mut instance: ::protobuf::lazy::Lazy<CreateConnectionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateConnectionResponse,
        };
        unsafe {
            instance.get(CreateConnectionResponse::new)
        }
    }
}

impl ::protobuf::Clear for CreateConnectionResponse {
    fn clear(&mut self) {
        self.clear_user_id();
        self.clear_connection_accepted();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateConnectionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateConnectionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JobStatusRequest {
    // message fields
    pub user_id: ::std::string::String,
    pub job_ids: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl JobStatusRequest {
    pub fn new() -> JobStatusRequest {
        ::std::default::Default::default()
    }

    // string user_id = 1;

    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }

    // repeated int32 job_ids = 2;

    pub fn clear_job_ids(&mut self) {
        self.job_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_job_ids(&mut self, v: ::std::vec::Vec<i32>) {
        self.job_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_job_ids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.job_ids
    }

    // Take field
    pub fn take_job_ids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.job_ids, ::std::vec::Vec::new())
    }

    pub fn get_job_ids(&self) -> &[i32] {
        &self.job_ids
    }
}

impl ::protobuf::Message for JobStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.job_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user_id);
        }
        for value in &self.job_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.user_id.is_empty() {
            os.write_string(1, &self.user_id)?;
        }
        for v in &self.job_ids {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JobStatusRequest {
        JobStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_id",
                    |m: &JobStatusRequest| { &m.user_id },
                    |m: &mut JobStatusRequest| { &mut m.user_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "job_ids",
                    |m: &JobStatusRequest| { &m.job_ids },
                    |m: &mut JobStatusRequest| { &mut m.job_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<JobStatusRequest>(
                    "JobStatusRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static JobStatusRequest {
        static mut instance: ::protobuf::lazy::Lazy<JobStatusRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const JobStatusRequest,
        };
        unsafe {
            instance.get(JobStatusRequest::new)
        }
    }
}

impl ::protobuf::Clear for JobStatusRequest {
    fn clear(&mut self) {
        self.clear_user_id();
        self.clear_job_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JobStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JobStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JobStatus {
    // message fields
    pub job_id: i32,
    pub status: JobStatus_Status,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl JobStatus {
    pub fn new() -> JobStatus {
        ::std::default::Default::default()
    }

    // int32 job_id = 2;

    pub fn clear_job_id(&mut self) {
        self.job_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_job_id(&mut self, v: i32) {
        self.job_id = v;
    }

    pub fn get_job_id(&self) -> i32 {
        self.job_id
    }

    // .JobStatus.Status status = 3;

    pub fn clear_status(&mut self) {
        self.status = JobStatus_Status::BLOCKED;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: JobStatus_Status) {
        self.status = v;
    }

    pub fn get_status(&self) -> JobStatus_Status {
        self.status
    }
}

impl ::protobuf::Message for JobStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.job_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.job_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.job_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.status != JobStatus_Status::BLOCKED {
            my_size += ::protobuf::rt::enum_size(3, self.status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.job_id != 0 {
            os.write_int32(2, self.job_id)?;
        }
        if self.status != JobStatus_Status::BLOCKED {
            os.write_enum(3, self.status.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JobStatus {
        JobStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "job_id",
                    |m: &JobStatus| { &m.job_id },
                    |m: &mut JobStatus| { &mut m.job_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<JobStatus_Status>>(
                    "status",
                    |m: &JobStatus| { &m.status },
                    |m: &mut JobStatus| { &mut m.status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<JobStatus>(
                    "JobStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static JobStatus {
        static mut instance: ::protobuf::lazy::Lazy<JobStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const JobStatus,
        };
        unsafe {
            instance.get(JobStatus::new)
        }
    }
}

impl ::protobuf::Clear for JobStatus {
    fn clear(&mut self) {
        self.clear_job_id();
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JobStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JobStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum JobStatus_Status {
    BLOCKED = 0,
    QUEUED = 1,
    RUNNING = 2,
    COMPLETED = 4,
    HALTED = 5,
    CANCELLED = 6,
}

impl ::protobuf::ProtobufEnum for JobStatus_Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<JobStatus_Status> {
        match value {
            0 => ::std::option::Option::Some(JobStatus_Status::BLOCKED),
            1 => ::std::option::Option::Some(JobStatus_Status::QUEUED),
            2 => ::std::option::Option::Some(JobStatus_Status::RUNNING),
            4 => ::std::option::Option::Some(JobStatus_Status::COMPLETED),
            5 => ::std::option::Option::Some(JobStatus_Status::HALTED),
            6 => ::std::option::Option::Some(JobStatus_Status::CANCELLED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [JobStatus_Status] = &[
            JobStatus_Status::BLOCKED,
            JobStatus_Status::QUEUED,
            JobStatus_Status::RUNNING,
            JobStatus_Status::COMPLETED,
            JobStatus_Status::HALTED,
            JobStatus_Status::CANCELLED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("JobStatus_Status", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for JobStatus_Status {
}

impl ::std::default::Default for JobStatus_Status {
    fn default() -> Self {
        JobStatus_Status::BLOCKED
    }
}

impl ::protobuf::reflect::ProtobufValue for JobStatus_Status {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JobStatusResponse {
    // message fields
    pub job_statuses: ::protobuf::RepeatedField<JobStatus>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl JobStatusResponse {
    pub fn new() -> JobStatusResponse {
        ::std::default::Default::default()
    }

    // repeated .JobStatus job_statuses = 1;

    pub fn clear_job_statuses(&mut self) {
        self.job_statuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_job_statuses(&mut self, v: ::protobuf::RepeatedField<JobStatus>) {
        self.job_statuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_job_statuses(&mut self) -> &mut ::protobuf::RepeatedField<JobStatus> {
        &mut self.job_statuses
    }

    // Take field
    pub fn take_job_statuses(&mut self) -> ::protobuf::RepeatedField<JobStatus> {
        ::std::mem::replace(&mut self.job_statuses, ::protobuf::RepeatedField::new())
    }

    pub fn get_job_statuses(&self) -> &[JobStatus] {
        &self.job_statuses
    }
}

impl ::protobuf::Message for JobStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.job_statuses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.job_statuses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.job_statuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.job_statuses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JobStatusResponse {
        JobStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JobStatus>>(
                    "job_statuses",
                    |m: &JobStatusResponse| { &m.job_statuses },
                    |m: &mut JobStatusResponse| { &mut m.job_statuses },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<JobStatusResponse>(
                    "JobStatusResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static JobStatusResponse {
        static mut instance: ::protobuf::lazy::Lazy<JobStatusResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const JobStatusResponse,
        };
        unsafe {
            instance.get(JobStatusResponse::new)
        }
    }
}

impl ::protobuf::Clear for JobStatusResponse {
    fn clear(&mut self) {
        self.clear_job_statuses();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JobStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JobStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkerInputRequest {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WorkerInputRequest {
    pub fn new() -> WorkerInputRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for WorkerInputRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerInputRequest {
        WorkerInputRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<WorkerInputRequest>(
                    "WorkerInputRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerInputRequest {
        static mut instance: ::protobuf::lazy::Lazy<WorkerInputRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerInputRequest,
        };
        unsafe {
            instance.get(WorkerInputRequest::new)
        }
    }
}

impl ::protobuf::Clear for WorkerInputRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerInputRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkerInputResponse {
    // message fields
    pub function_closure: ::std::vec::Vec<u8>,
    pub map_type: WorkerInputResponse_MapType,
    pub datapacks: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WorkerInputResponse {
    pub fn new() -> WorkerInputResponse {
        ::std::default::Default::default()
    }

    // bytes function_closure = 1;

    pub fn clear_function_closure(&mut self) {
        self.function_closure.clear();
    }

    // Param is passed by value, moved
    pub fn set_function_closure(&mut self, v: ::std::vec::Vec<u8>) {
        self.function_closure = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function_closure(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.function_closure
    }

    // Take field
    pub fn take_function_closure(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.function_closure, ::std::vec::Vec::new())
    }

    pub fn get_function_closure(&self) -> &[u8] {
        &self.function_closure
    }

    // .WorkerInputResponse.MapType map_type = 2;

    pub fn clear_map_type(&mut self) {
        self.map_type = WorkerInputResponse_MapType::SINGLE_IN_MULTI_OUT;
    }

    // Param is passed by value, moved
    pub fn set_map_type(&mut self, v: WorkerInputResponse_MapType) {
        self.map_type = v;
    }

    pub fn get_map_type(&self) -> WorkerInputResponse_MapType {
        self.map_type
    }

    // repeated bytes datapacks = 3;

    pub fn clear_datapacks(&mut self) {
        self.datapacks.clear();
    }

    // Param is passed by value, moved
    pub fn set_datapacks(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.datapacks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_datapacks(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.datapacks
    }

    // Take field
    pub fn take_datapacks(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.datapacks, ::protobuf::RepeatedField::new())
    }

    pub fn get_datapacks(&self) -> &[::std::vec::Vec<u8>] {
        &self.datapacks
    }
}

impl ::protobuf::Message for WorkerInputResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.function_closure)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.map_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.datapacks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.function_closure.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.function_closure);
        }
        if self.map_type != WorkerInputResponse_MapType::SINGLE_IN_MULTI_OUT {
            my_size += ::protobuf::rt::enum_size(2, self.map_type);
        }
        for value in &self.datapacks {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.function_closure.is_empty() {
            os.write_bytes(1, &self.function_closure)?;
        }
        if self.map_type != WorkerInputResponse_MapType::SINGLE_IN_MULTI_OUT {
            os.write_enum(2, self.map_type.value())?;
        }
        for v in &self.datapacks {
            os.write_bytes(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerInputResponse {
        WorkerInputResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "function_closure",
                    |m: &WorkerInputResponse| { &m.function_closure },
                    |m: &mut WorkerInputResponse| { &mut m.function_closure },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WorkerInputResponse_MapType>>(
                    "map_type",
                    |m: &WorkerInputResponse| { &m.map_type },
                    |m: &mut WorkerInputResponse| { &mut m.map_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "datapacks",
                    |m: &WorkerInputResponse| { &m.datapacks },
                    |m: &mut WorkerInputResponse| { &mut m.datapacks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkerInputResponse>(
                    "WorkerInputResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerInputResponse {
        static mut instance: ::protobuf::lazy::Lazy<WorkerInputResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerInputResponse,
        };
        unsafe {
            instance.get(WorkerInputResponse::new)
        }
    }
}

impl ::protobuf::Clear for WorkerInputResponse {
    fn clear(&mut self) {
        self.clear_function_closure();
        self.clear_map_type();
        self.clear_datapacks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerInputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerInputResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WorkerInputResponse_MapType {
    SINGLE_IN_MULTI_OUT = 0,
    SINGLE_IN_SINGLE_OUT = 1,
    MULTI_IN_SINGLE_OUT = 2,
}

impl ::protobuf::ProtobufEnum for WorkerInputResponse_MapType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WorkerInputResponse_MapType> {
        match value {
            0 => ::std::option::Option::Some(WorkerInputResponse_MapType::SINGLE_IN_MULTI_OUT),
            1 => ::std::option::Option::Some(WorkerInputResponse_MapType::SINGLE_IN_SINGLE_OUT),
            2 => ::std::option::Option::Some(WorkerInputResponse_MapType::MULTI_IN_SINGLE_OUT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WorkerInputResponse_MapType] = &[
            WorkerInputResponse_MapType::SINGLE_IN_MULTI_OUT,
            WorkerInputResponse_MapType::SINGLE_IN_SINGLE_OUT,
            WorkerInputResponse_MapType::MULTI_IN_SINGLE_OUT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("WorkerInputResponse_MapType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for WorkerInputResponse_MapType {
}

impl ::std::default::Default for WorkerInputResponse_MapType {
    fn default() -> Self {
        WorkerInputResponse_MapType::SINGLE_IN_MULTI_OUT
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerInputResponse_MapType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkerOutputRequest {
    // message fields
    pub datapacks: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WorkerOutputRequest {
    pub fn new() -> WorkerOutputRequest {
        ::std::default::Default::default()
    }

    // repeated bytes datapacks = 1;

    pub fn clear_datapacks(&mut self) {
        self.datapacks.clear();
    }

    // Param is passed by value, moved
    pub fn set_datapacks(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.datapacks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_datapacks(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.datapacks
    }

    // Take field
    pub fn take_datapacks(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.datapacks, ::protobuf::RepeatedField::new())
    }

    pub fn get_datapacks(&self) -> &[::std::vec::Vec<u8>] {
        &self.datapacks
    }
}

impl ::protobuf::Message for WorkerOutputRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.datapacks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.datapacks {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.datapacks {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerOutputRequest {
        WorkerOutputRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "datapacks",
                    |m: &WorkerOutputRequest| { &m.datapacks },
                    |m: &mut WorkerOutputRequest| { &mut m.datapacks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkerOutputRequest>(
                    "WorkerOutputRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerOutputRequest {
        static mut instance: ::protobuf::lazy::Lazy<WorkerOutputRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerOutputRequest,
        };
        unsafe {
            instance.get(WorkerOutputRequest::new)
        }
    }
}

impl ::protobuf::Clear for WorkerOutputRequest {
    fn clear(&mut self) {
        self.clear_datapacks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerOutputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerOutputRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkerOutputResponse {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WorkerOutputResponse {
    pub fn new() -> WorkerOutputResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for WorkerOutputResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerOutputResponse {
        WorkerOutputResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<WorkerOutputResponse>(
                    "WorkerOutputResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerOutputResponse {
        static mut instance: ::protobuf::lazy::Lazy<WorkerOutputResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerOutputResponse,
        };
        unsafe {
            instance.get(WorkerOutputResponse::new)
        }
    }
}

impl ::protobuf::Clear for WorkerOutputResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerOutputResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerOutputResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleWorkerRequest {
    // message oneof groups
    pub request: ::std::option::Option<SingleWorkerRequest_oneof_request>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum SingleWorkerRequest_oneof_request {
    input_request(WorkerInputRequest),
    output_request(WorkerOutputRequest),
}

impl SingleWorkerRequest {
    pub fn new() -> SingleWorkerRequest {
        ::std::default::Default::default()
    }

    // .WorkerInputRequest input_request = 1;

    pub fn clear_input_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_input_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(SingleWorkerRequest_oneof_request::input_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_input_request(&mut self, v: WorkerInputRequest) {
        self.request = ::std::option::Option::Some(SingleWorkerRequest_oneof_request::input_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_input_request(&mut self) -> &mut WorkerInputRequest {
        if let ::std::option::Option::Some(SingleWorkerRequest_oneof_request::input_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(SingleWorkerRequest_oneof_request::input_request(WorkerInputRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(SingleWorkerRequest_oneof_request::input_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_input_request(&mut self) -> WorkerInputRequest {
        if self.has_input_request() {
            match self.request.take() {
                ::std::option::Option::Some(SingleWorkerRequest_oneof_request::input_request(v)) => v,
                _ => panic!(),
            }
        } else {
            WorkerInputRequest::new()
        }
    }

    pub fn get_input_request(&self) -> &WorkerInputRequest {
        match self.request {
            ::std::option::Option::Some(SingleWorkerRequest_oneof_request::input_request(ref v)) => v,
            _ => WorkerInputRequest::default_instance(),
        }
    }

    // .WorkerOutputRequest output_request = 2;

    pub fn clear_output_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_output_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(SingleWorkerRequest_oneof_request::output_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_output_request(&mut self, v: WorkerOutputRequest) {
        self.request = ::std::option::Option::Some(SingleWorkerRequest_oneof_request::output_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_output_request(&mut self) -> &mut WorkerOutputRequest {
        if let ::std::option::Option::Some(SingleWorkerRequest_oneof_request::output_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(SingleWorkerRequest_oneof_request::output_request(WorkerOutputRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(SingleWorkerRequest_oneof_request::output_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_output_request(&mut self) -> WorkerOutputRequest {
        if self.has_output_request() {
            match self.request.take() {
                ::std::option::Option::Some(SingleWorkerRequest_oneof_request::output_request(v)) => v,
                _ => panic!(),
            }
        } else {
            WorkerOutputRequest::new()
        }
    }

    pub fn get_output_request(&self) -> &WorkerOutputRequest {
        match self.request {
            ::std::option::Option::Some(SingleWorkerRequest_oneof_request::output_request(ref v)) => v,
            _ => WorkerOutputRequest::default_instance(),
        }
    }
}

impl ::protobuf::Message for SingleWorkerRequest {
    fn is_initialized(&self) -> bool {
        if let Some(SingleWorkerRequest_oneof_request::input_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SingleWorkerRequest_oneof_request::output_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(SingleWorkerRequest_oneof_request::input_request(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(SingleWorkerRequest_oneof_request::output_request(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &SingleWorkerRequest_oneof_request::input_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SingleWorkerRequest_oneof_request::output_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &SingleWorkerRequest_oneof_request::input_request(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SingleWorkerRequest_oneof_request::output_request(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleWorkerRequest {
        SingleWorkerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WorkerInputRequest>(
                    "input_request",
                    SingleWorkerRequest::has_input_request,
                    SingleWorkerRequest::get_input_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WorkerOutputRequest>(
                    "output_request",
                    SingleWorkerRequest::has_output_request,
                    SingleWorkerRequest::get_output_request,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SingleWorkerRequest>(
                    "SingleWorkerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SingleWorkerRequest {
        static mut instance: ::protobuf::lazy::Lazy<SingleWorkerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SingleWorkerRequest,
        };
        unsafe {
            instance.get(SingleWorkerRequest::new)
        }
    }
}

impl ::protobuf::Clear for SingleWorkerRequest {
    fn clear(&mut self) {
        self.clear_input_request();
        self.clear_output_request();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleWorkerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleWorkerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleWorkerResponse {
    // message oneof groups
    pub response: ::std::option::Option<SingleWorkerResponse_oneof_response>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum SingleWorkerResponse_oneof_response {
    input_response(WorkerInputResponse),
    output_response(WorkerOutputResponse),
}

impl SingleWorkerResponse {
    pub fn new() -> SingleWorkerResponse {
        ::std::default::Default::default()
    }

    // .WorkerInputResponse input_response = 1;

    pub fn clear_input_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_input_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(SingleWorkerResponse_oneof_response::input_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_input_response(&mut self, v: WorkerInputResponse) {
        self.response = ::std::option::Option::Some(SingleWorkerResponse_oneof_response::input_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_input_response(&mut self) -> &mut WorkerInputResponse {
        if let ::std::option::Option::Some(SingleWorkerResponse_oneof_response::input_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(SingleWorkerResponse_oneof_response::input_response(WorkerInputResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(SingleWorkerResponse_oneof_response::input_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_input_response(&mut self) -> WorkerInputResponse {
        if self.has_input_response() {
            match self.response.take() {
                ::std::option::Option::Some(SingleWorkerResponse_oneof_response::input_response(v)) => v,
                _ => panic!(),
            }
        } else {
            WorkerInputResponse::new()
        }
    }

    pub fn get_input_response(&self) -> &WorkerInputResponse {
        match self.response {
            ::std::option::Option::Some(SingleWorkerResponse_oneof_response::input_response(ref v)) => v,
            _ => WorkerInputResponse::default_instance(),
        }
    }

    // .WorkerOutputResponse output_response = 2;

    pub fn clear_output_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_output_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(SingleWorkerResponse_oneof_response::output_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_output_response(&mut self, v: WorkerOutputResponse) {
        self.response = ::std::option::Option::Some(SingleWorkerResponse_oneof_response::output_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_output_response(&mut self) -> &mut WorkerOutputResponse {
        if let ::std::option::Option::Some(SingleWorkerResponse_oneof_response::output_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(SingleWorkerResponse_oneof_response::output_response(WorkerOutputResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(SingleWorkerResponse_oneof_response::output_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_output_response(&mut self) -> WorkerOutputResponse {
        if self.has_output_response() {
            match self.response.take() {
                ::std::option::Option::Some(SingleWorkerResponse_oneof_response::output_response(v)) => v,
                _ => panic!(),
            }
        } else {
            WorkerOutputResponse::new()
        }
    }

    pub fn get_output_response(&self) -> &WorkerOutputResponse {
        match self.response {
            ::std::option::Option::Some(SingleWorkerResponse_oneof_response::output_response(ref v)) => v,
            _ => WorkerOutputResponse::default_instance(),
        }
    }
}

impl ::protobuf::Message for SingleWorkerResponse {
    fn is_initialized(&self) -> bool {
        if let Some(SingleWorkerResponse_oneof_response::input_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SingleWorkerResponse_oneof_response::output_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(SingleWorkerResponse_oneof_response::input_response(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(SingleWorkerResponse_oneof_response::output_response(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &SingleWorkerResponse_oneof_response::input_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SingleWorkerResponse_oneof_response::output_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &SingleWorkerResponse_oneof_response::input_response(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SingleWorkerResponse_oneof_response::output_response(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleWorkerResponse {
        SingleWorkerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WorkerInputResponse>(
                    "input_response",
                    SingleWorkerResponse::has_input_response,
                    SingleWorkerResponse::get_input_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WorkerOutputResponse>(
                    "output_response",
                    SingleWorkerResponse::has_output_response,
                    SingleWorkerResponse::get_output_response,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SingleWorkerResponse>(
                    "SingleWorkerResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SingleWorkerResponse {
        static mut instance: ::protobuf::lazy::Lazy<SingleWorkerResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SingleWorkerResponse,
        };
        unsafe {
            instance.get(SingleWorkerResponse::new)
        }
    }
}

impl ::protobuf::Clear for SingleWorkerResponse {
    fn clear(&mut self) {
        self.clear_input_response();
        self.clear_output_response();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleWorkerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleWorkerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnectionRequest {
    // message fields
    pub user_id: ::std::string::String,
    pub action: ConnectionRequest_Action,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ConnectionRequest {
    pub fn new() -> ConnectionRequest {
        ::std::default::Default::default()
    }

    // string user_id = 1;

    pub fn clear_user_id(&mut self) {
        self.user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: ::std::string::String) {
        self.user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.user_id
    }

    // Take field
    pub fn take_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_id, ::std::string::String::new())
    }

    pub fn get_user_id(&self) -> &str {
        &self.user_id
    }

    // .ConnectionRequest.Action action = 2;

    pub fn clear_action(&mut self) {
        self.action = ConnectionRequest_Action::HEARTBEAT;
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ConnectionRequest_Action) {
        self.action = v;
    }

    pub fn get_action(&self) -> ConnectionRequest_Action {
        self.action
    }
}

impl ::protobuf::Message for ConnectionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_id)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user_id);
        }
        if self.action != ConnectionRequest_Action::HEARTBEAT {
            my_size += ::protobuf::rt::enum_size(2, self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.user_id.is_empty() {
            os.write_string(1, &self.user_id)?;
        }
        if self.action != ConnectionRequest_Action::HEARTBEAT {
            os.write_enum(2, self.action.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectionRequest {
        ConnectionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user_id",
                    |m: &ConnectionRequest| { &m.user_id },
                    |m: &mut ConnectionRequest| { &mut m.user_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConnectionRequest_Action>>(
                    "action",
                    |m: &ConnectionRequest| { &m.action },
                    |m: &mut ConnectionRequest| { &mut m.action },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConnectionRequest>(
                    "ConnectionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConnectionRequest {
        static mut instance: ::protobuf::lazy::Lazy<ConnectionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConnectionRequest,
        };
        unsafe {
            instance.get(ConnectionRequest::new)
        }
    }
}

impl ::protobuf::Clear for ConnectionRequest {
    fn clear(&mut self) {
        self.clear_user_id();
        self.clear_action();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConnectionRequest_Action {
    HEARTBEAT = 0,
    CLOSE_CONNECTION = 1,
}

impl ::protobuf::ProtobufEnum for ConnectionRequest_Action {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConnectionRequest_Action> {
        match value {
            0 => ::std::option::Option::Some(ConnectionRequest_Action::HEARTBEAT),
            1 => ::std::option::Option::Some(ConnectionRequest_Action::CLOSE_CONNECTION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConnectionRequest_Action] = &[
            ConnectionRequest_Action::HEARTBEAT,
            ConnectionRequest_Action::CLOSE_CONNECTION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ConnectionRequest_Action", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ConnectionRequest_Action {
}

impl ::std::default::Default for ConnectionRequest_Action {
    fn default() -> Self {
        ConnectionRequest_Action::HEARTBEAT
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectionRequest_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnectionResponse {
    // message fields
    pub request_accepted: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ConnectionResponse {
    pub fn new() -> ConnectionResponse {
        ::std::default::Default::default()
    }

    // bool request_accepted = 1;

    pub fn clear_request_accepted(&mut self) {
        self.request_accepted = false;
    }

    // Param is passed by value, moved
    pub fn set_request_accepted(&mut self, v: bool) {
        self.request_accepted = v;
    }

    pub fn get_request_accepted(&self) -> bool {
        self.request_accepted
    }
}

impl ::protobuf::Message for ConnectionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.request_accepted = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.request_accepted != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.request_accepted != false {
            os.write_bool(1, self.request_accepted)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectionResponse {
        ConnectionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "request_accepted",
                    |m: &ConnectionResponse| { &m.request_accepted },
                    |m: &mut ConnectionResponse| { &mut m.request_accepted },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConnectionResponse>(
                    "ConnectionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConnectionResponse {
        static mut instance: ::protobuf::lazy::Lazy<ConnectionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConnectionResponse,
        };
        unsafe {
            instance.get(ConnectionResponse::new)
        }
    }
}

impl ::protobuf::Clear for ConnectionResponse {
    fn clear(&mut self) {
        self.clear_request_accepted();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServerMessage {
    // message fields
    pub action: ServerMessage_Action,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ServerMessage {
    pub fn new() -> ServerMessage {
        ::std::default::Default::default()
    }

    // .ServerMessage.Action action = 1;

    pub fn clear_action(&mut self) {
        self.action = ServerMessage_Action::USER_TIMEOUT;
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ServerMessage_Action) {
        self.action = v;
    }

    pub fn get_action(&self) -> ServerMessage_Action {
        self.action
    }
}

impl ::protobuf::Message for ServerMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.action != ServerMessage_Action::USER_TIMEOUT {
            my_size += ::protobuf::rt::enum_size(1, self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.action != ServerMessage_Action::USER_TIMEOUT {
            os.write_enum(1, self.action.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerMessage {
        ServerMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ServerMessage_Action>>(
                    "action",
                    |m: &ServerMessage| { &m.action },
                    |m: &mut ServerMessage| { &mut m.action },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServerMessage>(
                    "ServerMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ServerMessage {
        static mut instance: ::protobuf::lazy::Lazy<ServerMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServerMessage,
        };
        unsafe {
            instance.get(ServerMessage::new)
        }
    }
}

impl ::protobuf::Clear for ServerMessage {
    fn clear(&mut self) {
        self.clear_action();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ServerMessage_Action {
    USER_TIMEOUT = 0,
    MISSING_JOBS = 1,
    INTERNAL_SERVER_ERROR = 2,
}

impl ::protobuf::ProtobufEnum for ServerMessage_Action {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ServerMessage_Action> {
        match value {
            0 => ::std::option::Option::Some(ServerMessage_Action::USER_TIMEOUT),
            1 => ::std::option::Option::Some(ServerMessage_Action::MISSING_JOBS),
            2 => ::std::option::Option::Some(ServerMessage_Action::INTERNAL_SERVER_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ServerMessage_Action] = &[
            ServerMessage_Action::USER_TIMEOUT,
            ServerMessage_Action::MISSING_JOBS,
            ServerMessage_Action::INTERNAL_SERVER_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ServerMessage_Action", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ServerMessage_Action {
}

impl ::std::default::Default for ServerMessage_Action {
    fn default() -> Self {
        ServerMessage_Action::USER_TIMEOUT
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerMessage_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleUserRequest {
    // message oneof groups
    pub request: ::std::option::Option<SingleUserRequest_oneof_request>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum SingleUserRequest_oneof_request {
    create_connection_request(CreateConnectionRequest),
    connection_request(ConnectionRequest),
    job_submission(JobSubmission),
    data_retrieval_request(DataRetrievalRequest),
    job_status_request(JobStatusRequest),
}

impl SingleUserRequest {
    pub fn new() -> SingleUserRequest {
        ::std::default::Default::default()
    }

    // .CreateConnectionRequest create_connection_request = 1;

    pub fn clear_create_connection_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_create_connection_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(SingleUserRequest_oneof_request::create_connection_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_connection_request(&mut self, v: CreateConnectionRequest) {
        self.request = ::std::option::Option::Some(SingleUserRequest_oneof_request::create_connection_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create_connection_request(&mut self) -> &mut CreateConnectionRequest {
        if let ::std::option::Option::Some(SingleUserRequest_oneof_request::create_connection_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(SingleUserRequest_oneof_request::create_connection_request(CreateConnectionRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(SingleUserRequest_oneof_request::create_connection_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create_connection_request(&mut self) -> CreateConnectionRequest {
        if self.has_create_connection_request() {
            match self.request.take() {
                ::std::option::Option::Some(SingleUserRequest_oneof_request::create_connection_request(v)) => v,
                _ => panic!(),
            }
        } else {
            CreateConnectionRequest::new()
        }
    }

    pub fn get_create_connection_request(&self) -> &CreateConnectionRequest {
        match self.request {
            ::std::option::Option::Some(SingleUserRequest_oneof_request::create_connection_request(ref v)) => v,
            _ => CreateConnectionRequest::default_instance(),
        }
    }

    // .ConnectionRequest connection_request = 2;

    pub fn clear_connection_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_connection_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(SingleUserRequest_oneof_request::connection_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_connection_request(&mut self, v: ConnectionRequest) {
        self.request = ::std::option::Option::Some(SingleUserRequest_oneof_request::connection_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_connection_request(&mut self) -> &mut ConnectionRequest {
        if let ::std::option::Option::Some(SingleUserRequest_oneof_request::connection_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(SingleUserRequest_oneof_request::connection_request(ConnectionRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(SingleUserRequest_oneof_request::connection_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_connection_request(&mut self) -> ConnectionRequest {
        if self.has_connection_request() {
            match self.request.take() {
                ::std::option::Option::Some(SingleUserRequest_oneof_request::connection_request(v)) => v,
                _ => panic!(),
            }
        } else {
            ConnectionRequest::new()
        }
    }

    pub fn get_connection_request(&self) -> &ConnectionRequest {
        match self.request {
            ::std::option::Option::Some(SingleUserRequest_oneof_request::connection_request(ref v)) => v,
            _ => ConnectionRequest::default_instance(),
        }
    }

    // .JobSubmission job_submission = 3;

    pub fn clear_job_submission(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_job_submission(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(SingleUserRequest_oneof_request::job_submission(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_job_submission(&mut self, v: JobSubmission) {
        self.request = ::std::option::Option::Some(SingleUserRequest_oneof_request::job_submission(v))
    }

    // Mutable pointer to the field.
    pub fn mut_job_submission(&mut self) -> &mut JobSubmission {
        if let ::std::option::Option::Some(SingleUserRequest_oneof_request::job_submission(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(SingleUserRequest_oneof_request::job_submission(JobSubmission::new()));
        }
        match self.request {
            ::std::option::Option::Some(SingleUserRequest_oneof_request::job_submission(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_job_submission(&mut self) -> JobSubmission {
        if self.has_job_submission() {
            match self.request.take() {
                ::std::option::Option::Some(SingleUserRequest_oneof_request::job_submission(v)) => v,
                _ => panic!(),
            }
        } else {
            JobSubmission::new()
        }
    }

    pub fn get_job_submission(&self) -> &JobSubmission {
        match self.request {
            ::std::option::Option::Some(SingleUserRequest_oneof_request::job_submission(ref v)) => v,
            _ => JobSubmission::default_instance(),
        }
    }

    // .DataRetrievalRequest data_retrieval_request = 4;

    pub fn clear_data_retrieval_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_data_retrieval_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(SingleUserRequest_oneof_request::data_retrieval_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_data_retrieval_request(&mut self, v: DataRetrievalRequest) {
        self.request = ::std::option::Option::Some(SingleUserRequest_oneof_request::data_retrieval_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_data_retrieval_request(&mut self) -> &mut DataRetrievalRequest {
        if let ::std::option::Option::Some(SingleUserRequest_oneof_request::data_retrieval_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(SingleUserRequest_oneof_request::data_retrieval_request(DataRetrievalRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(SingleUserRequest_oneof_request::data_retrieval_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_data_retrieval_request(&mut self) -> DataRetrievalRequest {
        if self.has_data_retrieval_request() {
            match self.request.take() {
                ::std::option::Option::Some(SingleUserRequest_oneof_request::data_retrieval_request(v)) => v,
                _ => panic!(),
            }
        } else {
            DataRetrievalRequest::new()
        }
    }

    pub fn get_data_retrieval_request(&self) -> &DataRetrievalRequest {
        match self.request {
            ::std::option::Option::Some(SingleUserRequest_oneof_request::data_retrieval_request(ref v)) => v,
            _ => DataRetrievalRequest::default_instance(),
        }
    }

    // .JobStatusRequest job_status_request = 5;

    pub fn clear_job_status_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_job_status_request(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(SingleUserRequest_oneof_request::job_status_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_job_status_request(&mut self, v: JobStatusRequest) {
        self.request = ::std::option::Option::Some(SingleUserRequest_oneof_request::job_status_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_job_status_request(&mut self) -> &mut JobStatusRequest {
        if let ::std::option::Option::Some(SingleUserRequest_oneof_request::job_status_request(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(SingleUserRequest_oneof_request::job_status_request(JobStatusRequest::new()));
        }
        match self.request {
            ::std::option::Option::Some(SingleUserRequest_oneof_request::job_status_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_job_status_request(&mut self) -> JobStatusRequest {
        if self.has_job_status_request() {
            match self.request.take() {
                ::std::option::Option::Some(SingleUserRequest_oneof_request::job_status_request(v)) => v,
                _ => panic!(),
            }
        } else {
            JobStatusRequest::new()
        }
    }

    pub fn get_job_status_request(&self) -> &JobStatusRequest {
        match self.request {
            ::std::option::Option::Some(SingleUserRequest_oneof_request::job_status_request(ref v)) => v,
            _ => JobStatusRequest::default_instance(),
        }
    }
}

impl ::protobuf::Message for SingleUserRequest {
    fn is_initialized(&self) -> bool {
        if let Some(SingleUserRequest_oneof_request::create_connection_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SingleUserRequest_oneof_request::connection_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SingleUserRequest_oneof_request::job_submission(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SingleUserRequest_oneof_request::data_retrieval_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SingleUserRequest_oneof_request::job_status_request(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(SingleUserRequest_oneof_request::create_connection_request(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(SingleUserRequest_oneof_request::connection_request(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(SingleUserRequest_oneof_request::job_submission(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(SingleUserRequest_oneof_request::data_retrieval_request(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(SingleUserRequest_oneof_request::job_status_request(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &SingleUserRequest_oneof_request::create_connection_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SingleUserRequest_oneof_request::connection_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SingleUserRequest_oneof_request::job_submission(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SingleUserRequest_oneof_request::data_retrieval_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SingleUserRequest_oneof_request::job_status_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &SingleUserRequest_oneof_request::create_connection_request(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SingleUserRequest_oneof_request::connection_request(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SingleUserRequest_oneof_request::job_submission(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SingleUserRequest_oneof_request::data_retrieval_request(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SingleUserRequest_oneof_request::job_status_request(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleUserRequest {
        SingleUserRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CreateConnectionRequest>(
                    "create_connection_request",
                    SingleUserRequest::has_create_connection_request,
                    SingleUserRequest::get_create_connection_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConnectionRequest>(
                    "connection_request",
                    SingleUserRequest::has_connection_request,
                    SingleUserRequest::get_connection_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, JobSubmission>(
                    "job_submission",
                    SingleUserRequest::has_job_submission,
                    SingleUserRequest::get_job_submission,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DataRetrievalRequest>(
                    "data_retrieval_request",
                    SingleUserRequest::has_data_retrieval_request,
                    SingleUserRequest::get_data_retrieval_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, JobStatusRequest>(
                    "job_status_request",
                    SingleUserRequest::has_job_status_request,
                    SingleUserRequest::get_job_status_request,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SingleUserRequest>(
                    "SingleUserRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SingleUserRequest {
        static mut instance: ::protobuf::lazy::Lazy<SingleUserRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SingleUserRequest,
        };
        unsafe {
            instance.get(SingleUserRequest::new)
        }
    }
}

impl ::protobuf::Clear for SingleUserRequest {
    fn clear(&mut self) {
        self.clear_create_connection_request();
        self.clear_connection_request();
        self.clear_job_submission();
        self.clear_data_retrieval_request();
        self.clear_job_status_request();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleUserRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleUserRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleUserResponse {
    // message oneof groups
    pub response: ::std::option::Option<SingleUserResponse_oneof_response>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum SingleUserResponse_oneof_response {
    create_connection_response(CreateConnectionResponse),
    job_submission_response(JobSubmissionResponse),
    data_retrieval_response(DataRetrievalResponse),
    job_status_response(JobStatusResponse),
    connection_response(ConnectionResponse),
    server_message(ServerMessage),
}

impl SingleUserResponse {
    pub fn new() -> SingleUserResponse {
        ::std::default::Default::default()
    }

    // .CreateConnectionResponse create_connection_response = 1;

    pub fn clear_create_connection_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_create_connection_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(SingleUserResponse_oneof_response::create_connection_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_create_connection_response(&mut self, v: CreateConnectionResponse) {
        self.response = ::std::option::Option::Some(SingleUserResponse_oneof_response::create_connection_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_create_connection_response(&mut self) -> &mut CreateConnectionResponse {
        if let ::std::option::Option::Some(SingleUserResponse_oneof_response::create_connection_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(SingleUserResponse_oneof_response::create_connection_response(CreateConnectionResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(SingleUserResponse_oneof_response::create_connection_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_create_connection_response(&mut self) -> CreateConnectionResponse {
        if self.has_create_connection_response() {
            match self.response.take() {
                ::std::option::Option::Some(SingleUserResponse_oneof_response::create_connection_response(v)) => v,
                _ => panic!(),
            }
        } else {
            CreateConnectionResponse::new()
        }
    }

    pub fn get_create_connection_response(&self) -> &CreateConnectionResponse {
        match self.response {
            ::std::option::Option::Some(SingleUserResponse_oneof_response::create_connection_response(ref v)) => v,
            _ => CreateConnectionResponse::default_instance(),
        }
    }

    // .JobSubmissionResponse job_submission_response = 2;

    pub fn clear_job_submission_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_job_submission_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(SingleUserResponse_oneof_response::job_submission_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_job_submission_response(&mut self, v: JobSubmissionResponse) {
        self.response = ::std::option::Option::Some(SingleUserResponse_oneof_response::job_submission_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_job_submission_response(&mut self) -> &mut JobSubmissionResponse {
        if let ::std::option::Option::Some(SingleUserResponse_oneof_response::job_submission_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(SingleUserResponse_oneof_response::job_submission_response(JobSubmissionResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(SingleUserResponse_oneof_response::job_submission_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_job_submission_response(&mut self) -> JobSubmissionResponse {
        if self.has_job_submission_response() {
            match self.response.take() {
                ::std::option::Option::Some(SingleUserResponse_oneof_response::job_submission_response(v)) => v,
                _ => panic!(),
            }
        } else {
            JobSubmissionResponse::new()
        }
    }

    pub fn get_job_submission_response(&self) -> &JobSubmissionResponse {
        match self.response {
            ::std::option::Option::Some(SingleUserResponse_oneof_response::job_submission_response(ref v)) => v,
            _ => JobSubmissionResponse::default_instance(),
        }
    }

    // .DataRetrievalResponse data_retrieval_response = 3;

    pub fn clear_data_retrieval_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_data_retrieval_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(SingleUserResponse_oneof_response::data_retrieval_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_data_retrieval_response(&mut self, v: DataRetrievalResponse) {
        self.response = ::std::option::Option::Some(SingleUserResponse_oneof_response::data_retrieval_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_data_retrieval_response(&mut self) -> &mut DataRetrievalResponse {
        if let ::std::option::Option::Some(SingleUserResponse_oneof_response::data_retrieval_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(SingleUserResponse_oneof_response::data_retrieval_response(DataRetrievalResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(SingleUserResponse_oneof_response::data_retrieval_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_data_retrieval_response(&mut self) -> DataRetrievalResponse {
        if self.has_data_retrieval_response() {
            match self.response.take() {
                ::std::option::Option::Some(SingleUserResponse_oneof_response::data_retrieval_response(v)) => v,
                _ => panic!(),
            }
        } else {
            DataRetrievalResponse::new()
        }
    }

    pub fn get_data_retrieval_response(&self) -> &DataRetrievalResponse {
        match self.response {
            ::std::option::Option::Some(SingleUserResponse_oneof_response::data_retrieval_response(ref v)) => v,
            _ => DataRetrievalResponse::default_instance(),
        }
    }

    // .JobStatusResponse job_status_response = 4;

    pub fn clear_job_status_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_job_status_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(SingleUserResponse_oneof_response::job_status_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_job_status_response(&mut self, v: JobStatusResponse) {
        self.response = ::std::option::Option::Some(SingleUserResponse_oneof_response::job_status_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_job_status_response(&mut self) -> &mut JobStatusResponse {
        if let ::std::option::Option::Some(SingleUserResponse_oneof_response::job_status_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(SingleUserResponse_oneof_response::job_status_response(JobStatusResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(SingleUserResponse_oneof_response::job_status_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_job_status_response(&mut self) -> JobStatusResponse {
        if self.has_job_status_response() {
            match self.response.take() {
                ::std::option::Option::Some(SingleUserResponse_oneof_response::job_status_response(v)) => v,
                _ => panic!(),
            }
        } else {
            JobStatusResponse::new()
        }
    }

    pub fn get_job_status_response(&self) -> &JobStatusResponse {
        match self.response {
            ::std::option::Option::Some(SingleUserResponse_oneof_response::job_status_response(ref v)) => v,
            _ => JobStatusResponse::default_instance(),
        }
    }

    // .ConnectionResponse connection_response = 5;

    pub fn clear_connection_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_connection_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(SingleUserResponse_oneof_response::connection_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_connection_response(&mut self, v: ConnectionResponse) {
        self.response = ::std::option::Option::Some(SingleUserResponse_oneof_response::connection_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_connection_response(&mut self) -> &mut ConnectionResponse {
        if let ::std::option::Option::Some(SingleUserResponse_oneof_response::connection_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(SingleUserResponse_oneof_response::connection_response(ConnectionResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(SingleUserResponse_oneof_response::connection_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_connection_response(&mut self) -> ConnectionResponse {
        if self.has_connection_response() {
            match self.response.take() {
                ::std::option::Option::Some(SingleUserResponse_oneof_response::connection_response(v)) => v,
                _ => panic!(),
            }
        } else {
            ConnectionResponse::new()
        }
    }

    pub fn get_connection_response(&self) -> &ConnectionResponse {
        match self.response {
            ::std::option::Option::Some(SingleUserResponse_oneof_response::connection_response(ref v)) => v,
            _ => ConnectionResponse::default_instance(),
        }
    }

    // .ServerMessage server_message = 6;

    pub fn clear_server_message(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_server_message(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(SingleUserResponse_oneof_response::server_message(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_server_message(&mut self, v: ServerMessage) {
        self.response = ::std::option::Option::Some(SingleUserResponse_oneof_response::server_message(v))
    }

    // Mutable pointer to the field.
    pub fn mut_server_message(&mut self) -> &mut ServerMessage {
        if let ::std::option::Option::Some(SingleUserResponse_oneof_response::server_message(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(SingleUserResponse_oneof_response::server_message(ServerMessage::new()));
        }
        match self.response {
            ::std::option::Option::Some(SingleUserResponse_oneof_response::server_message(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_server_message(&mut self) -> ServerMessage {
        if self.has_server_message() {
            match self.response.take() {
                ::std::option::Option::Some(SingleUserResponse_oneof_response::server_message(v)) => v,
                _ => panic!(),
            }
        } else {
            ServerMessage::new()
        }
    }

    pub fn get_server_message(&self) -> &ServerMessage {
        match self.response {
            ::std::option::Option::Some(SingleUserResponse_oneof_response::server_message(ref v)) => v,
            _ => ServerMessage::default_instance(),
        }
    }
}

impl ::protobuf::Message for SingleUserResponse {
    fn is_initialized(&self) -> bool {
        if let Some(SingleUserResponse_oneof_response::create_connection_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SingleUserResponse_oneof_response::job_submission_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SingleUserResponse_oneof_response::data_retrieval_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SingleUserResponse_oneof_response::job_status_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SingleUserResponse_oneof_response::connection_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SingleUserResponse_oneof_response::server_message(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(SingleUserResponse_oneof_response::create_connection_response(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(SingleUserResponse_oneof_response::job_submission_response(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(SingleUserResponse_oneof_response::data_retrieval_response(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(SingleUserResponse_oneof_response::job_status_response(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(SingleUserResponse_oneof_response::connection_response(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(SingleUserResponse_oneof_response::server_message(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &SingleUserResponse_oneof_response::create_connection_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SingleUserResponse_oneof_response::job_submission_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SingleUserResponse_oneof_response::data_retrieval_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SingleUserResponse_oneof_response::job_status_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SingleUserResponse_oneof_response::connection_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SingleUserResponse_oneof_response::server_message(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &SingleUserResponse_oneof_response::create_connection_response(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SingleUserResponse_oneof_response::job_submission_response(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SingleUserResponse_oneof_response::data_retrieval_response(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SingleUserResponse_oneof_response::job_status_response(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SingleUserResponse_oneof_response::connection_response(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SingleUserResponse_oneof_response::server_message(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleUserResponse {
        SingleUserResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CreateConnectionResponse>(
                    "create_connection_response",
                    SingleUserResponse::has_create_connection_response,
                    SingleUserResponse::get_create_connection_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, JobSubmissionResponse>(
                    "job_submission_response",
                    SingleUserResponse::has_job_submission_response,
                    SingleUserResponse::get_job_submission_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DataRetrievalResponse>(
                    "data_retrieval_response",
                    SingleUserResponse::has_data_retrieval_response,
                    SingleUserResponse::get_data_retrieval_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, JobStatusResponse>(
                    "job_status_response",
                    SingleUserResponse::has_job_status_response,
                    SingleUserResponse::get_job_status_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConnectionResponse>(
                    "connection_response",
                    SingleUserResponse::has_connection_response,
                    SingleUserResponse::get_connection_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ServerMessage>(
                    "server_message",
                    SingleUserResponse::has_server_message,
                    SingleUserResponse::get_server_message,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SingleUserResponse>(
                    "SingleUserResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SingleUserResponse {
        static mut instance: ::protobuf::lazy::Lazy<SingleUserResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SingleUserResponse,
        };
        unsafe {
            instance.get(SingleUserResponse::new)
        }
    }
}

impl ::protobuf::Clear for SingleUserResponse {
    fn clear(&mut self) {
        self.clear_create_connection_response();
        self.clear_job_submission_response();
        self.clear_data_retrieval_response();
        self.clear_job_status_response();
        self.clear_connection_response();
        self.clear_server_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleUserResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleUserResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12user_cluster.proto\"F\n\x14DataRetrievalRequest\x12\x17\n\x07user_\
    id\x18\x01\x20\x01(\tR\x06userId\x12\x15\n\x06job_id\x18\x02\x20\x01(\
    \x05R\x05jobId\"-\n\x15DataRetrievalResponse\x12\x14\n\x05bytes\x18\x01\
    \x20\x01(\x0cR\x05bytes\"-\n\x0bInputAction\x12\x1e\n\x0bdata_loc_in\x18\
    \x01\x20\x01(\x0cR\tdataLocIn\"\xd7\x01\n\tMapAction\x12,\n\x07mapType\
    \x18\x01\x20\x01(\x0e2\x12.MapAction.MapTypeR\x07mapType\x12\x1a\n\tjob_\
    id_in\x18\x02\x20\x01(\x05R\x07jobIdIn\x12)\n\x10function_closure\x18\
    \x03\x20\x01(\x0cR\x0ffunctionClosure\"U\n\x07MapType\x12\x17\n\x13SINGL\
    E_IN_MULTI_OUT\x10\0\x12\x18\n\x14SINGLE_IN_SINGLE_OUT\x10\x01\x12\x17\n\
    \x13MULTI_IN_SINGLE_OUT\x10\x02\"l\n\x03Job\x12\x15\n\x06job_id\x18\x01\
    \x20\x01(\x05R\x05jobId\x12$\n\x05input\x18\x04\x20\x01(\x0b2\x0c.InputA\
    ctionH\0R\x05input\x12\x1e\n\x03map\x18\x05\x20\x01(\x0b2\n.MapActionH\0\
    R\x03mapB\x08\n\x06action\"B\n\rJobSubmission\x12\x17\n\x07user_id\x18\
    \x01\x20\x01(\tR\x06userId\x12\x18\n\x04jobs\x18\x02\x20\x03(\x0b2\x04.J\
    obR\x04jobs\":\n\x15JobSubmissionResponse\x12!\n\x0cjob_accepted\x18\x01\
    \x20\x01(\x08R\x0bjobAccepted\"b\n\x17CreateConnectionRequest\x12&\n\x0e\
    authentication\x18\x01\x20\x01(\tR\x0eauthentication\x12\x1f\n\x0bdocker\
    _name\x18\x02\x20\x01(\tR\ndockerName\"d\n\x18CreateConnectionResponse\
    \x12\x17\n\x07user_id\x18\x01\x20\x01(\tR\x06userId\x12/\n\x13connection\
    _accepted\x18\x02\x20\x01(\x08R\x12connectionAccepted\"D\n\x10JobStatusR\
    equest\x12\x17\n\x07user_id\x18\x01\x20\x01(\tR\x06userId\x12\x17\n\x07j\
    ob_ids\x18\x02\x20\x03(\x05R\x06jobIds\"\xa7\x01\n\tJobStatus\x12\x15\n\
    \x06job_id\x18\x02\x20\x01(\x05R\x05jobId\x12)\n\x06status\x18\x03\x20\
    \x01(\x0e2\x11.JobStatus.StatusR\x06status\"X\n\x06Status\x12\x0b\n\x07B\
    LOCKED\x10\0\x12\n\n\x06QUEUED\x10\x01\x12\x0b\n\x07RUNNING\x10\x02\x12\
    \r\n\tCOMPLETED\x10\x04\x12\n\n\x06HALTED\x10\x05\x12\r\n\tCANCELLED\x10\
    \x06\"B\n\x11JobStatusResponse\x12-\n\x0cjob_statuses\x18\x01\x20\x03(\
    \x0b2\n.JobStatusR\x0bjobStatuses\"\x14\n\x12WorkerInputRequest\"\xee\
    \x01\n\x13WorkerInputResponse\x12)\n\x10function_closure\x18\x01\x20\x01\
    (\x0cR\x0ffunctionClosure\x127\n\x08map_type\x18\x02\x20\x01(\x0e2\x1c.W\
    orkerInputResponse.MapTypeR\x07mapType\x12\x1c\n\tdatapacks\x18\x03\x20\
    \x03(\x0cR\tdatapacks\"U\n\x07MapType\x12\x17\n\x13SINGLE_IN_MULTI_OUT\
    \x10\0\x12\x18\n\x14SINGLE_IN_SINGLE_OUT\x10\x01\x12\x17\n\x13MULTI_IN_S\
    INGLE_OUT\x10\x02\"3\n\x13WorkerOutputRequest\x12\x1c\n\tdatapacks\x18\
    \x01\x20\x03(\x0cR\tdatapacks\"\x16\n\x14WorkerOutputResponse\"\x9b\x01\
    \n\x13SingleWorkerRequest\x12:\n\rinput_request\x18\x01\x20\x01(\x0b2\
    \x13.WorkerInputRequestH\0R\x0cinputRequest\x12=\n\x0eoutput_request\x18\
    \x02\x20\x01(\x0b2\x14.WorkerOutputRequestH\0R\routputRequestB\t\n\x07re\
    quest\"\xa3\x01\n\x14SingleWorkerResponse\x12=\n\x0einput_response\x18\
    \x01\x20\x01(\x0b2\x14.WorkerInputResponseH\0R\rinputResponse\x12@\n\x0f\
    output_response\x18\x02\x20\x01(\x0b2\x15.WorkerOutputResponseH\0R\x0eou\
    tputResponseB\n\n\x08response\"\x8e\x01\n\x11ConnectionRequest\x12\x17\n\
    \x07user_id\x18\x01\x20\x01(\tR\x06userId\x121\n\x06action\x18\x02\x20\
    \x01(\x0e2\x19.ConnectionRequest.ActionR\x06action\"-\n\x06Action\x12\r\
    \n\tHEARTBEAT\x10\0\x12\x14\n\x10CLOSE_CONNECTION\x10\x01\"?\n\x12Connec\
    tionResponse\x12)\n\x10request_accepted\x18\x01\x20\x01(\x08R\x0frequest\
    Accepted\"\x87\x01\n\rServerMessage\x12-\n\x06action\x18\x01\x20\x01(\
    \x0e2\x15.ServerMessage.ActionR\x06action\"G\n\x06Action\x12\x10\n\x0cUS\
    ER_TIMEOUT\x10\0\x12\x10\n\x0cMISSING_JOBS\x10\x01\x12\x19\n\x15INTERNAL\
    _SERVER_ERROR\x10\x02\"\x86\x03\n\x11SingleUserRequest\x12V\n\x19create_\
    connection_request\x18\x01\x20\x01(\x0b2\x18.CreateConnectionRequestH\0R\
    \x17createConnectionRequest\x12C\n\x12connection_request\x18\x02\x20\x01\
    (\x0b2\x12.ConnectionRequestH\0R\x11connectionRequest\x127\n\x0ejob_subm\
    ission\x18\x03\x20\x01(\x0b2\x0e.JobSubmissionH\0R\rjobSubmission\x12M\n\
    \x16data_retrieval_request\x18\x04\x20\x01(\x0b2\x15.DataRetrievalReques\
    tH\0R\x14dataRetrievalRequest\x12A\n\x12job_status_request\x18\x05\x20\
    \x01(\x0b2\x11.JobStatusRequestH\0R\x10jobStatusRequestB\t\n\x07request\
    \"\xe6\x03\n\x12SingleUserResponse\x12Y\n\x1acreate_connection_response\
    \x18\x01\x20\x01(\x0b2\x19.CreateConnectionResponseH\0R\x18createConnect\
    ionResponse\x12P\n\x17job_submission_response\x18\x02\x20\x01(\x0b2\x16.\
    JobSubmissionResponseH\0R\x15jobSubmissionResponse\x12P\n\x17data_retrie\
    val_response\x18\x03\x20\x01(\x0b2\x16.DataRetrievalResponseH\0R\x15data\
    RetrievalResponse\x12D\n\x13job_status_response\x18\x04\x20\x01(\x0b2\
    \x12.JobStatusResponseH\0R\x11jobStatusResponse\x12F\n\x13connection_res\
    ponse\x18\x05\x20\x01(\x0b2\x13.ConnectionResponseH\0R\x12connectionResp\
    onse\x127\n\x0eserver_message\x18\x06\x20\x01(\x0b2\x0e.ServerMessageH\0\
    R\rserverMessageB\n\n\x08responseb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
