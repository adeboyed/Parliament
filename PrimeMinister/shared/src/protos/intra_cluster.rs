// This file is generated by rust-protobuf 2.0.5. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct WorkerConnectionRequest {
    // message fields
    pub authentication: ::std::string::String,
    pub no_of_cores: i32,
    pub port: i32,
    pub ip_override: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WorkerConnectionRequest {
    pub fn new() -> WorkerConnectionRequest {
        ::std::default::Default::default()
    }

    // string authentication = 1;

    pub fn clear_authentication(&mut self) {
        self.authentication.clear();
    }

    // Param is passed by value, moved
    pub fn set_authentication(&mut self, v: ::std::string::String) {
        self.authentication = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authentication(&mut self) -> &mut ::std::string::String {
        &mut self.authentication
    }

    // Take field
    pub fn take_authentication(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.authentication, ::std::string::String::new())
    }

    pub fn get_authentication(&self) -> &str {
        &self.authentication
    }

    // int32 no_of_cores = 2;

    pub fn clear_no_of_cores(&mut self) {
        self.no_of_cores = 0;
    }

    // Param is passed by value, moved
    pub fn set_no_of_cores(&mut self, v: i32) {
        self.no_of_cores = v;
    }

    pub fn get_no_of_cores(&self) -> i32 {
        self.no_of_cores
    }

    // int32 port = 3;

    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = v;
    }

    pub fn get_port(&self) -> i32 {
        self.port
    }

    // string ip_override = 4;

    pub fn clear_ip_override(&mut self) {
        self.ip_override.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip_override(&mut self, v: ::std::string::String) {
        self.ip_override = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_override(&mut self) -> &mut ::std::string::String {
        &mut self.ip_override
    }

    // Take field
    pub fn take_ip_override(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ip_override, ::std::string::String::new())
    }

    pub fn get_ip_override(&self) -> &str {
        &self.ip_override
    }
}

impl ::protobuf::Message for WorkerConnectionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.authentication)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.no_of_cores = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ip_override)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.authentication.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.authentication);
        }
        if self.no_of_cores != 0 {
            my_size += ::protobuf::rt::value_size(2, self.no_of_cores, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(3, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.ip_override.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.ip_override);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.authentication.is_empty() {
            os.write_string(1, &self.authentication)?;
        }
        if self.no_of_cores != 0 {
            os.write_int32(2, self.no_of_cores)?;
        }
        if self.port != 0 {
            os.write_int32(3, self.port)?;
        }
        if !self.ip_override.is_empty() {
            os.write_string(4, &self.ip_override)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerConnectionRequest {
        WorkerConnectionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "authentication",
                    |m: &WorkerConnectionRequest| { &m.authentication },
                    |m: &mut WorkerConnectionRequest| { &mut m.authentication },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "no_of_cores",
                    |m: &WorkerConnectionRequest| { &m.no_of_cores },
                    |m: &mut WorkerConnectionRequest| { &mut m.no_of_cores },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "port",
                    |m: &WorkerConnectionRequest| { &m.port },
                    |m: &mut WorkerConnectionRequest| { &mut m.port },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ip_override",
                    |m: &WorkerConnectionRequest| { &m.ip_override },
                    |m: &mut WorkerConnectionRequest| { &mut m.ip_override },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkerConnectionRequest>(
                    "WorkerConnectionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerConnectionRequest {
        static mut instance: ::protobuf::lazy::Lazy<WorkerConnectionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerConnectionRequest,
        };
        unsafe {
            instance.get(WorkerConnectionRequest::new)
        }
    }
}

impl ::protobuf::Clear for WorkerConnectionRequest {
    fn clear(&mut self) {
        self.clear_authentication();
        self.clear_no_of_cores();
        self.clear_port();
        self.clear_ip_override();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerConnectionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerConnectionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkerConnectionResponse {
    // message fields
    pub worker_id: ::std::string::String,
    pub connection_accepted: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WorkerConnectionResponse {
    pub fn new() -> WorkerConnectionResponse {
        ::std::default::Default::default()
    }

    // string worker_id = 1;

    pub fn clear_worker_id(&mut self) {
        self.worker_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_worker_id(&mut self, v: ::std::string::String) {
        self.worker_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worker_id(&mut self) -> &mut ::std::string::String {
        &mut self.worker_id
    }

    // Take field
    pub fn take_worker_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.worker_id, ::std::string::String::new())
    }

    pub fn get_worker_id(&self) -> &str {
        &self.worker_id
    }

    // bool connection_accepted = 2;

    pub fn clear_connection_accepted(&mut self) {
        self.connection_accepted = false;
    }

    // Param is passed by value, moved
    pub fn set_connection_accepted(&mut self, v: bool) {
        self.connection_accepted = v;
    }

    pub fn get_connection_accepted(&self) -> bool {
        self.connection_accepted
    }
}

impl ::protobuf::Message for WorkerConnectionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.worker_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.connection_accepted = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.worker_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.worker_id);
        }
        if self.connection_accepted != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.worker_id.is_empty() {
            os.write_string(1, &self.worker_id)?;
        }
        if self.connection_accepted != false {
            os.write_bool(2, self.connection_accepted)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerConnectionResponse {
        WorkerConnectionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "worker_id",
                    |m: &WorkerConnectionResponse| { &m.worker_id },
                    |m: &mut WorkerConnectionResponse| { &mut m.worker_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "connection_accepted",
                    |m: &WorkerConnectionResponse| { &m.connection_accepted },
                    |m: &mut WorkerConnectionResponse| { &mut m.connection_accepted },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkerConnectionResponse>(
                    "WorkerConnectionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerConnectionResponse {
        static mut instance: ::protobuf::lazy::Lazy<WorkerConnectionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerConnectionResponse,
        };
        unsafe {
            instance.get(WorkerConnectionResponse::new)
        }
    }
}

impl ::protobuf::Clear for WorkerConnectionResponse {
    fn clear(&mut self) {
        self.clear_worker_id();
        self.clear_connection_accepted();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerConnectionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerConnectionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkerHeartbeatRequest {
    // message fields
    pub worker_id: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WorkerHeartbeatRequest {
    pub fn new() -> WorkerHeartbeatRequest {
        ::std::default::Default::default()
    }

    // string worker_id = 1;

    pub fn clear_worker_id(&mut self) {
        self.worker_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_worker_id(&mut self, v: ::std::string::String) {
        self.worker_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worker_id(&mut self) -> &mut ::std::string::String {
        &mut self.worker_id
    }

    // Take field
    pub fn take_worker_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.worker_id, ::std::string::String::new())
    }

    pub fn get_worker_id(&self) -> &str {
        &self.worker_id
    }
}

impl ::protobuf::Message for WorkerHeartbeatRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.worker_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.worker_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.worker_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.worker_id.is_empty() {
            os.write_string(1, &self.worker_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerHeartbeatRequest {
        WorkerHeartbeatRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "worker_id",
                    |m: &WorkerHeartbeatRequest| { &m.worker_id },
                    |m: &mut WorkerHeartbeatRequest| { &mut m.worker_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkerHeartbeatRequest>(
                    "WorkerHeartbeatRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerHeartbeatRequest {
        static mut instance: ::protobuf::lazy::Lazy<WorkerHeartbeatRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerHeartbeatRequest,
        };
        unsafe {
            instance.get(WorkerHeartbeatRequest::new)
        }
    }
}

impl ::protobuf::Clear for WorkerHeartbeatRequest {
    fn clear(&mut self) {
        self.clear_worker_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerHeartbeatRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerHeartbeatRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkerHeartbeatResponse {
    // message fields
    pub status: WorkerHeartbeatResponse_HeartbeatStatus,
    pub task_id: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WorkerHeartbeatResponse {
    pub fn new() -> WorkerHeartbeatResponse {
        ::std::default::Default::default()
    }

    // .WorkerHeartbeatResponse.HeartbeatStatus status = 1;

    pub fn clear_status(&mut self) {
        self.status = WorkerHeartbeatResponse_HeartbeatStatus::AWAITING_TASK;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: WorkerHeartbeatResponse_HeartbeatStatus) {
        self.status = v;
    }

    pub fn get_status(&self) -> WorkerHeartbeatResponse_HeartbeatStatus {
        self.status
    }

    // string task_id = 2;

    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: ::std::string::String) {
        self.task_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut ::std::string::String {
        &mut self.task_id
    }

    // Take field
    pub fn take_task_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.task_id, ::std::string::String::new())
    }

    pub fn get_task_id(&self) -> &str {
        &self.task_id
    }
}

impl ::protobuf::Message for WorkerHeartbeatResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.task_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != WorkerHeartbeatResponse_HeartbeatStatus::AWAITING_TASK {
            my_size += ::protobuf::rt::enum_size(1, self.status);
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.status != WorkerHeartbeatResponse_HeartbeatStatus::AWAITING_TASK {
            os.write_enum(1, self.status.value())?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerHeartbeatResponse {
        WorkerHeartbeatResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WorkerHeartbeatResponse_HeartbeatStatus>>(
                    "status",
                    |m: &WorkerHeartbeatResponse| { &m.status },
                    |m: &mut WorkerHeartbeatResponse| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "task_id",
                    |m: &WorkerHeartbeatResponse| { &m.task_id },
                    |m: &mut WorkerHeartbeatResponse| { &mut m.task_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkerHeartbeatResponse>(
                    "WorkerHeartbeatResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerHeartbeatResponse {
        static mut instance: ::protobuf::lazy::Lazy<WorkerHeartbeatResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerHeartbeatResponse,
        };
        unsafe {
            instance.get(WorkerHeartbeatResponse::new)
        }
    }
}

impl ::protobuf::Clear for WorkerHeartbeatResponse {
    fn clear(&mut self) {
        self.clear_status();
        self.clear_task_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerHeartbeatResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerHeartbeatResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WorkerHeartbeatResponse_HeartbeatStatus {
    AWAITING_TASK = 0,
    PROCESSING_TASK = 1,
    HALTED_TASK = 2,
    CANCELLED_TASK = 3,
}

impl ::protobuf::ProtobufEnum for WorkerHeartbeatResponse_HeartbeatStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WorkerHeartbeatResponse_HeartbeatStatus> {
        match value {
            0 => ::std::option::Option::Some(WorkerHeartbeatResponse_HeartbeatStatus::AWAITING_TASK),
            1 => ::std::option::Option::Some(WorkerHeartbeatResponse_HeartbeatStatus::PROCESSING_TASK),
            2 => ::std::option::Option::Some(WorkerHeartbeatResponse_HeartbeatStatus::HALTED_TASK),
            3 => ::std::option::Option::Some(WorkerHeartbeatResponse_HeartbeatStatus::CANCELLED_TASK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WorkerHeartbeatResponse_HeartbeatStatus] = &[
            WorkerHeartbeatResponse_HeartbeatStatus::AWAITING_TASK,
            WorkerHeartbeatResponse_HeartbeatStatus::PROCESSING_TASK,
            WorkerHeartbeatResponse_HeartbeatStatus::HALTED_TASK,
            WorkerHeartbeatResponse_HeartbeatStatus::CANCELLED_TASK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("WorkerHeartbeatResponse_HeartbeatStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for WorkerHeartbeatResponse_HeartbeatStatus {
}

impl ::std::default::Default for WorkerHeartbeatResponse_HeartbeatStatus {
    fn default() -> Self {
        WorkerHeartbeatResponse_HeartbeatStatus::AWAITING_TASK
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerHeartbeatResponse_HeartbeatStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkerTaskSubmissionRequest {
    // message fields
    pub worker_id: ::std::string::String,
    pub task_id: ::std::string::String,
    pub docker_name: ::std::string::String,
    pub data_in: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub closure: ::std::vec::Vec<u8>,
    pub map_type: WorkerTaskSubmissionRequest_MapType,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WorkerTaskSubmissionRequest {
    pub fn new() -> WorkerTaskSubmissionRequest {
        ::std::default::Default::default()
    }

    // string worker_id = 1;

    pub fn clear_worker_id(&mut self) {
        self.worker_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_worker_id(&mut self, v: ::std::string::String) {
        self.worker_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worker_id(&mut self) -> &mut ::std::string::String {
        &mut self.worker_id
    }

    // Take field
    pub fn take_worker_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.worker_id, ::std::string::String::new())
    }

    pub fn get_worker_id(&self) -> &str {
        &self.worker_id
    }

    // string task_id = 2;

    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: ::std::string::String) {
        self.task_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut ::std::string::String {
        &mut self.task_id
    }

    // Take field
    pub fn take_task_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.task_id, ::std::string::String::new())
    }

    pub fn get_task_id(&self) -> &str {
        &self.task_id
    }

    // string docker_name = 3;

    pub fn clear_docker_name(&mut self) {
        self.docker_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_docker_name(&mut self, v: ::std::string::String) {
        self.docker_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_docker_name(&mut self) -> &mut ::std::string::String {
        &mut self.docker_name
    }

    // Take field
    pub fn take_docker_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.docker_name, ::std::string::String::new())
    }

    pub fn get_docker_name(&self) -> &str {
        &self.docker_name
    }

    // repeated bytes data_in = 4;

    pub fn clear_data_in(&mut self) {
        self.data_in.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_in(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.data_in = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data_in(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.data_in
    }

    // Take field
    pub fn take_data_in(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.data_in, ::protobuf::RepeatedField::new())
    }

    pub fn get_data_in(&self) -> &[::std::vec::Vec<u8>] {
        &self.data_in
    }

    // bytes closure = 5;

    pub fn clear_closure(&mut self) {
        self.closure.clear();
    }

    // Param is passed by value, moved
    pub fn set_closure(&mut self, v: ::std::vec::Vec<u8>) {
        self.closure = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_closure(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.closure
    }

    // Take field
    pub fn take_closure(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.closure, ::std::vec::Vec::new())
    }

    pub fn get_closure(&self) -> &[u8] {
        &self.closure
    }

    // .WorkerTaskSubmissionRequest.MapType map_type = 6;

    pub fn clear_map_type(&mut self) {
        self.map_type = WorkerTaskSubmissionRequest_MapType::SINGLE_IN_MULTI_OUT;
    }

    // Param is passed by value, moved
    pub fn set_map_type(&mut self, v: WorkerTaskSubmissionRequest_MapType) {
        self.map_type = v;
    }

    pub fn get_map_type(&self) -> WorkerTaskSubmissionRequest_MapType {
        self.map_type
    }
}

impl ::protobuf::Message for WorkerTaskSubmissionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.worker_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.task_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.docker_name)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.data_in)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.closure)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.map_type, 6, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.worker_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.worker_id);
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        if !self.docker_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.docker_name);
        }
        for value in &self.data_in {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        if !self.closure.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.closure);
        }
        if self.map_type != WorkerTaskSubmissionRequest_MapType::SINGLE_IN_MULTI_OUT {
            my_size += ::protobuf::rt::enum_size(6, self.map_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.worker_id.is_empty() {
            os.write_string(1, &self.worker_id)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        if !self.docker_name.is_empty() {
            os.write_string(3, &self.docker_name)?;
        }
        for v in &self.data_in {
            os.write_bytes(4, &v)?;
        };
        if !self.closure.is_empty() {
            os.write_bytes(5, &self.closure)?;
        }
        if self.map_type != WorkerTaskSubmissionRequest_MapType::SINGLE_IN_MULTI_OUT {
            os.write_enum(6, self.map_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerTaskSubmissionRequest {
        WorkerTaskSubmissionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "worker_id",
                    |m: &WorkerTaskSubmissionRequest| { &m.worker_id },
                    |m: &mut WorkerTaskSubmissionRequest| { &mut m.worker_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "task_id",
                    |m: &WorkerTaskSubmissionRequest| { &m.task_id },
                    |m: &mut WorkerTaskSubmissionRequest| { &mut m.task_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "docker_name",
                    |m: &WorkerTaskSubmissionRequest| { &m.docker_name },
                    |m: &mut WorkerTaskSubmissionRequest| { &mut m.docker_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data_in",
                    |m: &WorkerTaskSubmissionRequest| { &m.data_in },
                    |m: &mut WorkerTaskSubmissionRequest| { &mut m.data_in },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "closure",
                    |m: &WorkerTaskSubmissionRequest| { &m.closure },
                    |m: &mut WorkerTaskSubmissionRequest| { &mut m.closure },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WorkerTaskSubmissionRequest_MapType>>(
                    "map_type",
                    |m: &WorkerTaskSubmissionRequest| { &m.map_type },
                    |m: &mut WorkerTaskSubmissionRequest| { &mut m.map_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkerTaskSubmissionRequest>(
                    "WorkerTaskSubmissionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerTaskSubmissionRequest {
        static mut instance: ::protobuf::lazy::Lazy<WorkerTaskSubmissionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerTaskSubmissionRequest,
        };
        unsafe {
            instance.get(WorkerTaskSubmissionRequest::new)
        }
    }
}

impl ::protobuf::Clear for WorkerTaskSubmissionRequest {
    fn clear(&mut self) {
        self.clear_worker_id();
        self.clear_task_id();
        self.clear_docker_name();
        self.clear_data_in();
        self.clear_closure();
        self.clear_map_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerTaskSubmissionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerTaskSubmissionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WorkerTaskSubmissionRequest_MapType {
    SINGLE_IN_MULTI_OUT = 0,
    SINGLE_IN_SINGLE_OUT = 1,
    MULTI_IN_SINGLE_OUT = 2,
}

impl ::protobuf::ProtobufEnum for WorkerTaskSubmissionRequest_MapType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WorkerTaskSubmissionRequest_MapType> {
        match value {
            0 => ::std::option::Option::Some(WorkerTaskSubmissionRequest_MapType::SINGLE_IN_MULTI_OUT),
            1 => ::std::option::Option::Some(WorkerTaskSubmissionRequest_MapType::SINGLE_IN_SINGLE_OUT),
            2 => ::std::option::Option::Some(WorkerTaskSubmissionRequest_MapType::MULTI_IN_SINGLE_OUT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WorkerTaskSubmissionRequest_MapType] = &[
            WorkerTaskSubmissionRequest_MapType::SINGLE_IN_MULTI_OUT,
            WorkerTaskSubmissionRequest_MapType::SINGLE_IN_SINGLE_OUT,
            WorkerTaskSubmissionRequest_MapType::MULTI_IN_SINGLE_OUT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("WorkerTaskSubmissionRequest_MapType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for WorkerTaskSubmissionRequest_MapType {
}

impl ::std::default::Default for WorkerTaskSubmissionRequest_MapType {
    fn default() -> Self {
        WorkerTaskSubmissionRequest_MapType::SINGLE_IN_MULTI_OUT
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerTaskSubmissionRequest_MapType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkerFinishedRequest {
    // message fields
    pub worker_id: ::std::string::String,
    pub task_id: ::std::string::String,
    pub status: WorkerFinishedRequest_WorkerTaskStatus,
    pub data_out: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WorkerFinishedRequest {
    pub fn new() -> WorkerFinishedRequest {
        ::std::default::Default::default()
    }

    // string worker_id = 1;

    pub fn clear_worker_id(&mut self) {
        self.worker_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_worker_id(&mut self, v: ::std::string::String) {
        self.worker_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worker_id(&mut self) -> &mut ::std::string::String {
        &mut self.worker_id
    }

    // Take field
    pub fn take_worker_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.worker_id, ::std::string::String::new())
    }

    pub fn get_worker_id(&self) -> &str {
        &self.worker_id
    }

    // string task_id = 2;

    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: ::std::string::String) {
        self.task_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id(&mut self) -> &mut ::std::string::String {
        &mut self.task_id
    }

    // Take field
    pub fn take_task_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.task_id, ::std::string::String::new())
    }

    pub fn get_task_id(&self) -> &str {
        &self.task_id
    }

    // .WorkerFinishedRequest.WorkerTaskStatus status = 3;

    pub fn clear_status(&mut self) {
        self.status = WorkerFinishedRequest_WorkerTaskStatus::TASK_FINISHED;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: WorkerFinishedRequest_WorkerTaskStatus) {
        self.status = v;
    }

    pub fn get_status(&self) -> WorkerFinishedRequest_WorkerTaskStatus {
        self.status
    }

    // repeated bytes data_out = 4;

    pub fn clear_data_out(&mut self) {
        self.data_out.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_out(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.data_out = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data_out(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.data_out
    }

    // Take field
    pub fn take_data_out(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.data_out, ::protobuf::RepeatedField::new())
    }

    pub fn get_data_out(&self) -> &[::std::vec::Vec<u8>] {
        &self.data_out
    }
}

impl ::protobuf::Message for WorkerFinishedRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.worker_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.task_id)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.data_out)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.worker_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.worker_id);
        }
        if !self.task_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.task_id);
        }
        if self.status != WorkerFinishedRequest_WorkerTaskStatus::TASK_FINISHED {
            my_size += ::protobuf::rt::enum_size(3, self.status);
        }
        for value in &self.data_out {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.worker_id.is_empty() {
            os.write_string(1, &self.worker_id)?;
        }
        if !self.task_id.is_empty() {
            os.write_string(2, &self.task_id)?;
        }
        if self.status != WorkerFinishedRequest_WorkerTaskStatus::TASK_FINISHED {
            os.write_enum(3, self.status.value())?;
        }
        for v in &self.data_out {
            os.write_bytes(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerFinishedRequest {
        WorkerFinishedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "worker_id",
                    |m: &WorkerFinishedRequest| { &m.worker_id },
                    |m: &mut WorkerFinishedRequest| { &mut m.worker_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "task_id",
                    |m: &WorkerFinishedRequest| { &m.task_id },
                    |m: &mut WorkerFinishedRequest| { &mut m.task_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WorkerFinishedRequest_WorkerTaskStatus>>(
                    "status",
                    |m: &WorkerFinishedRequest| { &m.status },
                    |m: &mut WorkerFinishedRequest| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data_out",
                    |m: &WorkerFinishedRequest| { &m.data_out },
                    |m: &mut WorkerFinishedRequest| { &mut m.data_out },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkerFinishedRequest>(
                    "WorkerFinishedRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerFinishedRequest {
        static mut instance: ::protobuf::lazy::Lazy<WorkerFinishedRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerFinishedRequest,
        };
        unsafe {
            instance.get(WorkerFinishedRequest::new)
        }
    }
}

impl ::protobuf::Clear for WorkerFinishedRequest {
    fn clear(&mut self) {
        self.clear_worker_id();
        self.clear_task_id();
        self.clear_status();
        self.clear_data_out();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerFinishedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerFinishedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WorkerFinishedRequest_WorkerTaskStatus {
    TASK_FINISHED = 0,
    TASK_ERRORED = 1,
}

impl ::protobuf::ProtobufEnum for WorkerFinishedRequest_WorkerTaskStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WorkerFinishedRequest_WorkerTaskStatus> {
        match value {
            0 => ::std::option::Option::Some(WorkerFinishedRequest_WorkerTaskStatus::TASK_FINISHED),
            1 => ::std::option::Option::Some(WorkerFinishedRequest_WorkerTaskStatus::TASK_ERRORED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WorkerFinishedRequest_WorkerTaskStatus] = &[
            WorkerFinishedRequest_WorkerTaskStatus::TASK_FINISHED,
            WorkerFinishedRequest_WorkerTaskStatus::TASK_ERRORED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("WorkerFinishedRequest_WorkerTaskStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for WorkerFinishedRequest_WorkerTaskStatus {
}

impl ::std::default::Default for WorkerFinishedRequest_WorkerTaskStatus {
    fn default() -> Self {
        WorkerFinishedRequest_WorkerTaskStatus::TASK_FINISHED
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerFinishedRequest_WorkerTaskStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkerFinishedResponse {
    // message fields
    pub response_processed: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WorkerFinishedResponse {
    pub fn new() -> WorkerFinishedResponse {
        ::std::default::Default::default()
    }

    // bool response_processed = 1;

    pub fn clear_response_processed(&mut self) {
        self.response_processed = false;
    }

    // Param is passed by value, moved
    pub fn set_response_processed(&mut self, v: bool) {
        self.response_processed = v;
    }

    pub fn get_response_processed(&self) -> bool {
        self.response_processed
    }
}

impl ::protobuf::Message for WorkerFinishedResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.response_processed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.response_processed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.response_processed != false {
            os.write_bool(1, self.response_processed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerFinishedResponse {
        WorkerFinishedResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "response_processed",
                    |m: &WorkerFinishedResponse| { &m.response_processed },
                    |m: &mut WorkerFinishedResponse| { &mut m.response_processed },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkerFinishedResponse>(
                    "WorkerFinishedResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerFinishedResponse {
        static mut instance: ::protobuf::lazy::Lazy<WorkerFinishedResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerFinishedResponse,
        };
        unsafe {
            instance.get(WorkerFinishedResponse::new)
        }
    }
}

impl ::protobuf::Clear for WorkerFinishedResponse {
    fn clear(&mut self) {
        self.clear_response_processed();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerFinishedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerFinishedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkerTaskCancellationRequest {
    // message fields
    pub worker_id: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WorkerTaskCancellationRequest {
    pub fn new() -> WorkerTaskCancellationRequest {
        ::std::default::Default::default()
    }

    // string worker_id = 1;

    pub fn clear_worker_id(&mut self) {
        self.worker_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_worker_id(&mut self, v: ::std::string::String) {
        self.worker_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worker_id(&mut self) -> &mut ::std::string::String {
        &mut self.worker_id
    }

    // Take field
    pub fn take_worker_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.worker_id, ::std::string::String::new())
    }

    pub fn get_worker_id(&self) -> &str {
        &self.worker_id
    }
}

impl ::protobuf::Message for WorkerTaskCancellationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.worker_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.worker_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.worker_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.worker_id.is_empty() {
            os.write_string(1, &self.worker_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerTaskCancellationRequest {
        WorkerTaskCancellationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "worker_id",
                    |m: &WorkerTaskCancellationRequest| { &m.worker_id },
                    |m: &mut WorkerTaskCancellationRequest| { &mut m.worker_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkerTaskCancellationRequest>(
                    "WorkerTaskCancellationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerTaskCancellationRequest {
        static mut instance: ::protobuf::lazy::Lazy<WorkerTaskCancellationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerTaskCancellationRequest,
        };
        unsafe {
            instance.get(WorkerTaskCancellationRequest::new)
        }
    }
}

impl ::protobuf::Clear for WorkerTaskCancellationRequest {
    fn clear(&mut self) {
        self.clear_worker_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerTaskCancellationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerTaskCancellationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConsensusRequest {
    // message fields
    pub action: ConsensusRequest_Action,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ConsensusRequest {
    pub fn new() -> ConsensusRequest {
        ::std::default::Default::default()
    }

    // .ConsensusRequest.Action action = 1;

    pub fn clear_action(&mut self) {
        self.action = ConsensusRequest_Action::SET_ACTIVE;
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ConsensusRequest_Action) {
        self.action = v;
    }

    pub fn get_action(&self) -> ConsensusRequest_Action {
        self.action
    }
}

impl ::protobuf::Message for ConsensusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.action != ConsensusRequest_Action::SET_ACTIVE {
            my_size += ::protobuf::rt::enum_size(1, self.action);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.action != ConsensusRequest_Action::SET_ACTIVE {
            os.write_enum(1, self.action.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConsensusRequest {
        ConsensusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConsensusRequest_Action>>(
                    "action",
                    |m: &ConsensusRequest| { &m.action },
                    |m: &mut ConsensusRequest| { &mut m.action },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConsensusRequest>(
                    "ConsensusRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConsensusRequest {
        static mut instance: ::protobuf::lazy::Lazy<ConsensusRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConsensusRequest,
        };
        unsafe {
            instance.get(ConsensusRequest::new)
        }
    }
}

impl ::protobuf::Clear for ConsensusRequest {
    fn clear(&mut self) {
        self.clear_action();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConsensusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsensusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConsensusRequest_Action {
    SET_ACTIVE = 0,
    SET_PASSIVE = 1,
    SHUTDOWN = 2,
}

impl ::protobuf::ProtobufEnum for ConsensusRequest_Action {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConsensusRequest_Action> {
        match value {
            0 => ::std::option::Option::Some(ConsensusRequest_Action::SET_ACTIVE),
            1 => ::std::option::Option::Some(ConsensusRequest_Action::SET_PASSIVE),
            2 => ::std::option::Option::Some(ConsensusRequest_Action::SHUTDOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConsensusRequest_Action] = &[
            ConsensusRequest_Action::SET_ACTIVE,
            ConsensusRequest_Action::SET_PASSIVE,
            ConsensusRequest_Action::SHUTDOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ConsensusRequest_Action", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ConsensusRequest_Action {
}

impl ::std::default::Default for ConsensusRequest_Action {
    fn default() -> Self {
        ConsensusRequest_Action::SET_ACTIVE
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsensusRequest_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConsensusResponse {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ConsensusResponse {
    pub fn new() -> ConsensusResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ConsensusResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConsensusResponse {
        ConsensusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ConsensusResponse>(
                    "ConsensusResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConsensusResponse {
        static mut instance: ::protobuf::lazy::Lazy<ConsensusResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConsensusResponse,
        };
        unsafe {
            instance.get(ConsensusResponse::new)
        }
    }
}

impl ::protobuf::Clear for ConsensusResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConsensusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsensusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleWorkerMessage {
    // message oneof groups
    pub message: ::std::option::Option<SingleWorkerMessage_oneof_message>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum SingleWorkerMessage_oneof_message {
    connection_request(WorkerConnectionRequest),
    heartbeat_response(WorkerHeartbeatResponse),
    finished_request(WorkerFinishedRequest),
    consensus_request(ConsensusRequest),
}

impl SingleWorkerMessage {
    pub fn new() -> SingleWorkerMessage {
        ::std::default::Default::default()
    }

    // .WorkerConnectionRequest connection_request = 1;

    pub fn clear_connection_request(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_connection_request(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(SingleWorkerMessage_oneof_message::connection_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_connection_request(&mut self, v: WorkerConnectionRequest) {
        self.message = ::std::option::Option::Some(SingleWorkerMessage_oneof_message::connection_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_connection_request(&mut self) -> &mut WorkerConnectionRequest {
        if let ::std::option::Option::Some(SingleWorkerMessage_oneof_message::connection_request(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(SingleWorkerMessage_oneof_message::connection_request(WorkerConnectionRequest::new()));
        }
        match self.message {
            ::std::option::Option::Some(SingleWorkerMessage_oneof_message::connection_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_connection_request(&mut self) -> WorkerConnectionRequest {
        if self.has_connection_request() {
            match self.message.take() {
                ::std::option::Option::Some(SingleWorkerMessage_oneof_message::connection_request(v)) => v,
                _ => panic!(),
            }
        } else {
            WorkerConnectionRequest::new()
        }
    }

    pub fn get_connection_request(&self) -> &WorkerConnectionRequest {
        match self.message {
            ::std::option::Option::Some(SingleWorkerMessage_oneof_message::connection_request(ref v)) => v,
            _ => WorkerConnectionRequest::default_instance(),
        }
    }

    // .WorkerHeartbeatResponse heartbeat_response = 2;

    pub fn clear_heartbeat_response(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_heartbeat_response(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(SingleWorkerMessage_oneof_message::heartbeat_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_heartbeat_response(&mut self, v: WorkerHeartbeatResponse) {
        self.message = ::std::option::Option::Some(SingleWorkerMessage_oneof_message::heartbeat_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_heartbeat_response(&mut self) -> &mut WorkerHeartbeatResponse {
        if let ::std::option::Option::Some(SingleWorkerMessage_oneof_message::heartbeat_response(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(SingleWorkerMessage_oneof_message::heartbeat_response(WorkerHeartbeatResponse::new()));
        }
        match self.message {
            ::std::option::Option::Some(SingleWorkerMessage_oneof_message::heartbeat_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_heartbeat_response(&mut self) -> WorkerHeartbeatResponse {
        if self.has_heartbeat_response() {
            match self.message.take() {
                ::std::option::Option::Some(SingleWorkerMessage_oneof_message::heartbeat_response(v)) => v,
                _ => panic!(),
            }
        } else {
            WorkerHeartbeatResponse::new()
        }
    }

    pub fn get_heartbeat_response(&self) -> &WorkerHeartbeatResponse {
        match self.message {
            ::std::option::Option::Some(SingleWorkerMessage_oneof_message::heartbeat_response(ref v)) => v,
            _ => WorkerHeartbeatResponse::default_instance(),
        }
    }

    // .WorkerFinishedRequest finished_request = 3;

    pub fn clear_finished_request(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_finished_request(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(SingleWorkerMessage_oneof_message::finished_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_finished_request(&mut self, v: WorkerFinishedRequest) {
        self.message = ::std::option::Option::Some(SingleWorkerMessage_oneof_message::finished_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_finished_request(&mut self) -> &mut WorkerFinishedRequest {
        if let ::std::option::Option::Some(SingleWorkerMessage_oneof_message::finished_request(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(SingleWorkerMessage_oneof_message::finished_request(WorkerFinishedRequest::new()));
        }
        match self.message {
            ::std::option::Option::Some(SingleWorkerMessage_oneof_message::finished_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_finished_request(&mut self) -> WorkerFinishedRequest {
        if self.has_finished_request() {
            match self.message.take() {
                ::std::option::Option::Some(SingleWorkerMessage_oneof_message::finished_request(v)) => v,
                _ => panic!(),
            }
        } else {
            WorkerFinishedRequest::new()
        }
    }

    pub fn get_finished_request(&self) -> &WorkerFinishedRequest {
        match self.message {
            ::std::option::Option::Some(SingleWorkerMessage_oneof_message::finished_request(ref v)) => v,
            _ => WorkerFinishedRequest::default_instance(),
        }
    }

    // .ConsensusRequest consensus_request = 4;

    pub fn clear_consensus_request(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_consensus_request(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(SingleWorkerMessage_oneof_message::consensus_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_consensus_request(&mut self, v: ConsensusRequest) {
        self.message = ::std::option::Option::Some(SingleWorkerMessage_oneof_message::consensus_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_consensus_request(&mut self) -> &mut ConsensusRequest {
        if let ::std::option::Option::Some(SingleWorkerMessage_oneof_message::consensus_request(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(SingleWorkerMessage_oneof_message::consensus_request(ConsensusRequest::new()));
        }
        match self.message {
            ::std::option::Option::Some(SingleWorkerMessage_oneof_message::consensus_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_consensus_request(&mut self) -> ConsensusRequest {
        if self.has_consensus_request() {
            match self.message.take() {
                ::std::option::Option::Some(SingleWorkerMessage_oneof_message::consensus_request(v)) => v,
                _ => panic!(),
            }
        } else {
            ConsensusRequest::new()
        }
    }

    pub fn get_consensus_request(&self) -> &ConsensusRequest {
        match self.message {
            ::std::option::Option::Some(SingleWorkerMessage_oneof_message::consensus_request(ref v)) => v,
            _ => ConsensusRequest::default_instance(),
        }
    }
}

impl ::protobuf::Message for SingleWorkerMessage {
    fn is_initialized(&self) -> bool {
        if let Some(SingleWorkerMessage_oneof_message::connection_request(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SingleWorkerMessage_oneof_message::heartbeat_response(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SingleWorkerMessage_oneof_message::finished_request(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SingleWorkerMessage_oneof_message::consensus_request(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(SingleWorkerMessage_oneof_message::connection_request(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(SingleWorkerMessage_oneof_message::heartbeat_response(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(SingleWorkerMessage_oneof_message::finished_request(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(SingleWorkerMessage_oneof_message::consensus_request(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &SingleWorkerMessage_oneof_message::connection_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SingleWorkerMessage_oneof_message::heartbeat_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SingleWorkerMessage_oneof_message::finished_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SingleWorkerMessage_oneof_message::consensus_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &SingleWorkerMessage_oneof_message::connection_request(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SingleWorkerMessage_oneof_message::heartbeat_response(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SingleWorkerMessage_oneof_message::finished_request(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SingleWorkerMessage_oneof_message::consensus_request(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleWorkerMessage {
        SingleWorkerMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WorkerConnectionRequest>(
                    "connection_request",
                    SingleWorkerMessage::has_connection_request,
                    SingleWorkerMessage::get_connection_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WorkerHeartbeatResponse>(
                    "heartbeat_response",
                    SingleWorkerMessage::has_heartbeat_response,
                    SingleWorkerMessage::get_heartbeat_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WorkerFinishedRequest>(
                    "finished_request",
                    SingleWorkerMessage::has_finished_request,
                    SingleWorkerMessage::get_finished_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConsensusRequest>(
                    "consensus_request",
                    SingleWorkerMessage::has_consensus_request,
                    SingleWorkerMessage::get_consensus_request,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SingleWorkerMessage>(
                    "SingleWorkerMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SingleWorkerMessage {
        static mut instance: ::protobuf::lazy::Lazy<SingleWorkerMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SingleWorkerMessage,
        };
        unsafe {
            instance.get(SingleWorkerMessage::new)
        }
    }
}

impl ::protobuf::Clear for SingleWorkerMessage {
    fn clear(&mut self) {
        self.clear_connection_request();
        self.clear_heartbeat_response();
        self.clear_finished_request();
        self.clear_consensus_request();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleWorkerMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleWorkerMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SingleServerMessage {
    // message oneof groups
    pub message: ::std::option::Option<SingleServerMessage_oneof_message>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum SingleServerMessage_oneof_message {
    connection_response(WorkerConnectionResponse),
    heartbeat_request(WorkerHeartbeatRequest),
    submission_request(WorkerTaskSubmissionRequest),
    finished_response(WorkerFinishedResponse),
    cancellation_request(WorkerTaskCancellationRequest),
    consensus_response(ConsensusResponse),
}

impl SingleServerMessage {
    pub fn new() -> SingleServerMessage {
        ::std::default::Default::default()
    }

    // .WorkerConnectionResponse connection_response = 1;

    pub fn clear_connection_response(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_connection_response(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(SingleServerMessage_oneof_message::connection_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_connection_response(&mut self, v: WorkerConnectionResponse) {
        self.message = ::std::option::Option::Some(SingleServerMessage_oneof_message::connection_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_connection_response(&mut self) -> &mut WorkerConnectionResponse {
        if let ::std::option::Option::Some(SingleServerMessage_oneof_message::connection_response(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(SingleServerMessage_oneof_message::connection_response(WorkerConnectionResponse::new()));
        }
        match self.message {
            ::std::option::Option::Some(SingleServerMessage_oneof_message::connection_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_connection_response(&mut self) -> WorkerConnectionResponse {
        if self.has_connection_response() {
            match self.message.take() {
                ::std::option::Option::Some(SingleServerMessage_oneof_message::connection_response(v)) => v,
                _ => panic!(),
            }
        } else {
            WorkerConnectionResponse::new()
        }
    }

    pub fn get_connection_response(&self) -> &WorkerConnectionResponse {
        match self.message {
            ::std::option::Option::Some(SingleServerMessage_oneof_message::connection_response(ref v)) => v,
            _ => WorkerConnectionResponse::default_instance(),
        }
    }

    // .WorkerHeartbeatRequest heartbeat_request = 2;

    pub fn clear_heartbeat_request(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_heartbeat_request(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(SingleServerMessage_oneof_message::heartbeat_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_heartbeat_request(&mut self, v: WorkerHeartbeatRequest) {
        self.message = ::std::option::Option::Some(SingleServerMessage_oneof_message::heartbeat_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_heartbeat_request(&mut self) -> &mut WorkerHeartbeatRequest {
        if let ::std::option::Option::Some(SingleServerMessage_oneof_message::heartbeat_request(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(SingleServerMessage_oneof_message::heartbeat_request(WorkerHeartbeatRequest::new()));
        }
        match self.message {
            ::std::option::Option::Some(SingleServerMessage_oneof_message::heartbeat_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_heartbeat_request(&mut self) -> WorkerHeartbeatRequest {
        if self.has_heartbeat_request() {
            match self.message.take() {
                ::std::option::Option::Some(SingleServerMessage_oneof_message::heartbeat_request(v)) => v,
                _ => panic!(),
            }
        } else {
            WorkerHeartbeatRequest::new()
        }
    }

    pub fn get_heartbeat_request(&self) -> &WorkerHeartbeatRequest {
        match self.message {
            ::std::option::Option::Some(SingleServerMessage_oneof_message::heartbeat_request(ref v)) => v,
            _ => WorkerHeartbeatRequest::default_instance(),
        }
    }

    // .WorkerTaskSubmissionRequest submission_request = 3;

    pub fn clear_submission_request(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_submission_request(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(SingleServerMessage_oneof_message::submission_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_submission_request(&mut self, v: WorkerTaskSubmissionRequest) {
        self.message = ::std::option::Option::Some(SingleServerMessage_oneof_message::submission_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_submission_request(&mut self) -> &mut WorkerTaskSubmissionRequest {
        if let ::std::option::Option::Some(SingleServerMessage_oneof_message::submission_request(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(SingleServerMessage_oneof_message::submission_request(WorkerTaskSubmissionRequest::new()));
        }
        match self.message {
            ::std::option::Option::Some(SingleServerMessage_oneof_message::submission_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_submission_request(&mut self) -> WorkerTaskSubmissionRequest {
        if self.has_submission_request() {
            match self.message.take() {
                ::std::option::Option::Some(SingleServerMessage_oneof_message::submission_request(v)) => v,
                _ => panic!(),
            }
        } else {
            WorkerTaskSubmissionRequest::new()
        }
    }

    pub fn get_submission_request(&self) -> &WorkerTaskSubmissionRequest {
        match self.message {
            ::std::option::Option::Some(SingleServerMessage_oneof_message::submission_request(ref v)) => v,
            _ => WorkerTaskSubmissionRequest::default_instance(),
        }
    }

    // .WorkerFinishedResponse finished_response = 4;

    pub fn clear_finished_response(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_finished_response(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(SingleServerMessage_oneof_message::finished_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_finished_response(&mut self, v: WorkerFinishedResponse) {
        self.message = ::std::option::Option::Some(SingleServerMessage_oneof_message::finished_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_finished_response(&mut self) -> &mut WorkerFinishedResponse {
        if let ::std::option::Option::Some(SingleServerMessage_oneof_message::finished_response(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(SingleServerMessage_oneof_message::finished_response(WorkerFinishedResponse::new()));
        }
        match self.message {
            ::std::option::Option::Some(SingleServerMessage_oneof_message::finished_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_finished_response(&mut self) -> WorkerFinishedResponse {
        if self.has_finished_response() {
            match self.message.take() {
                ::std::option::Option::Some(SingleServerMessage_oneof_message::finished_response(v)) => v,
                _ => panic!(),
            }
        } else {
            WorkerFinishedResponse::new()
        }
    }

    pub fn get_finished_response(&self) -> &WorkerFinishedResponse {
        match self.message {
            ::std::option::Option::Some(SingleServerMessage_oneof_message::finished_response(ref v)) => v,
            _ => WorkerFinishedResponse::default_instance(),
        }
    }

    // .WorkerTaskCancellationRequest cancellation_request = 5;

    pub fn clear_cancellation_request(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_cancellation_request(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(SingleServerMessage_oneof_message::cancellation_request(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cancellation_request(&mut self, v: WorkerTaskCancellationRequest) {
        self.message = ::std::option::Option::Some(SingleServerMessage_oneof_message::cancellation_request(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cancellation_request(&mut self) -> &mut WorkerTaskCancellationRequest {
        if let ::std::option::Option::Some(SingleServerMessage_oneof_message::cancellation_request(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(SingleServerMessage_oneof_message::cancellation_request(WorkerTaskCancellationRequest::new()));
        }
        match self.message {
            ::std::option::Option::Some(SingleServerMessage_oneof_message::cancellation_request(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cancellation_request(&mut self) -> WorkerTaskCancellationRequest {
        if self.has_cancellation_request() {
            match self.message.take() {
                ::std::option::Option::Some(SingleServerMessage_oneof_message::cancellation_request(v)) => v,
                _ => panic!(),
            }
        } else {
            WorkerTaskCancellationRequest::new()
        }
    }

    pub fn get_cancellation_request(&self) -> &WorkerTaskCancellationRequest {
        match self.message {
            ::std::option::Option::Some(SingleServerMessage_oneof_message::cancellation_request(ref v)) => v,
            _ => WorkerTaskCancellationRequest::default_instance(),
        }
    }

    // .ConsensusResponse consensus_response = 6;

    pub fn clear_consensus_response(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_consensus_response(&self) -> bool {
        match self.message {
            ::std::option::Option::Some(SingleServerMessage_oneof_message::consensus_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_consensus_response(&mut self, v: ConsensusResponse) {
        self.message = ::std::option::Option::Some(SingleServerMessage_oneof_message::consensus_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_consensus_response(&mut self) -> &mut ConsensusResponse {
        if let ::std::option::Option::Some(SingleServerMessage_oneof_message::consensus_response(_)) = self.message {
        } else {
            self.message = ::std::option::Option::Some(SingleServerMessage_oneof_message::consensus_response(ConsensusResponse::new()));
        }
        match self.message {
            ::std::option::Option::Some(SingleServerMessage_oneof_message::consensus_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_consensus_response(&mut self) -> ConsensusResponse {
        if self.has_consensus_response() {
            match self.message.take() {
                ::std::option::Option::Some(SingleServerMessage_oneof_message::consensus_response(v)) => v,
                _ => panic!(),
            }
        } else {
            ConsensusResponse::new()
        }
    }

    pub fn get_consensus_response(&self) -> &ConsensusResponse {
        match self.message {
            ::std::option::Option::Some(SingleServerMessage_oneof_message::consensus_response(ref v)) => v,
            _ => ConsensusResponse::default_instance(),
        }
    }
}

impl ::protobuf::Message for SingleServerMessage {
    fn is_initialized(&self) -> bool {
        if let Some(SingleServerMessage_oneof_message::connection_response(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SingleServerMessage_oneof_message::heartbeat_request(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SingleServerMessage_oneof_message::submission_request(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SingleServerMessage_oneof_message::finished_response(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SingleServerMessage_oneof_message::cancellation_request(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(SingleServerMessage_oneof_message::consensus_response(ref v)) = self.message {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(SingleServerMessage_oneof_message::connection_response(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(SingleServerMessage_oneof_message::heartbeat_request(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(SingleServerMessage_oneof_message::submission_request(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(SingleServerMessage_oneof_message::finished_response(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(SingleServerMessage_oneof_message::cancellation_request(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.message = ::std::option::Option::Some(SingleServerMessage_oneof_message::consensus_response(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &SingleServerMessage_oneof_message::connection_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SingleServerMessage_oneof_message::heartbeat_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SingleServerMessage_oneof_message::submission_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SingleServerMessage_oneof_message::finished_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SingleServerMessage_oneof_message::cancellation_request(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &SingleServerMessage_oneof_message::consensus_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.message {
            match v {
                &SingleServerMessage_oneof_message::connection_response(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SingleServerMessage_oneof_message::heartbeat_request(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SingleServerMessage_oneof_message::submission_request(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SingleServerMessage_oneof_message::finished_response(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SingleServerMessage_oneof_message::cancellation_request(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &SingleServerMessage_oneof_message::consensus_response(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SingleServerMessage {
        SingleServerMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WorkerConnectionResponse>(
                    "connection_response",
                    SingleServerMessage::has_connection_response,
                    SingleServerMessage::get_connection_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WorkerHeartbeatRequest>(
                    "heartbeat_request",
                    SingleServerMessage::has_heartbeat_request,
                    SingleServerMessage::get_heartbeat_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WorkerTaskSubmissionRequest>(
                    "submission_request",
                    SingleServerMessage::has_submission_request,
                    SingleServerMessage::get_submission_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WorkerFinishedResponse>(
                    "finished_response",
                    SingleServerMessage::has_finished_response,
                    SingleServerMessage::get_finished_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WorkerTaskCancellationRequest>(
                    "cancellation_request",
                    SingleServerMessage::has_cancellation_request,
                    SingleServerMessage::get_cancellation_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ConsensusResponse>(
                    "consensus_response",
                    SingleServerMessage::has_consensus_response,
                    SingleServerMessage::get_consensus_response,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SingleServerMessage>(
                    "SingleServerMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SingleServerMessage {
        static mut instance: ::protobuf::lazy::Lazy<SingleServerMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SingleServerMessage,
        };
        unsafe {
            instance.get(SingleServerMessage::new)
        }
    }
}

impl ::protobuf::Clear for SingleServerMessage {
    fn clear(&mut self) {
        self.clear_connection_response();
        self.clear_heartbeat_request();
        self.clear_submission_request();
        self.clear_finished_response();
        self.clear_cancellation_request();
        self.clear_consensus_response();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SingleServerMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SingleServerMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x13intra_cluster.proto\"\x96\x01\n\x17WorkerConnectionRequest\x12&\n\
    \x0eauthentication\x18\x01\x20\x01(\tR\x0eauthentication\x12\x1e\n\x0bno\
    _of_cores\x18\x02\x20\x01(\x05R\tnoOfCores\x12\x12\n\x04port\x18\x03\x20\
    \x01(\x05R\x04port\x12\x1f\n\x0bip_override\x18\x04\x20\x01(\tR\nipOverr\
    ide\"h\n\x18WorkerConnectionResponse\x12\x1b\n\tworker_id\x18\x01\x20\
    \x01(\tR\x08workerId\x12/\n\x13connection_accepted\x18\x02\x20\x01(\x08R\
    \x12connectionAccepted\"5\n\x16WorkerHeartbeatRequest\x12\x1b\n\tworker_\
    id\x18\x01\x20\x01(\tR\x08workerId\"\xd4\x01\n\x17WorkerHeartbeatRespons\
    e\x12@\n\x06status\x18\x01\x20\x01(\x0e2(.WorkerHeartbeatResponse.Heartb\
    eatStatusR\x06status\x12\x17\n\x07task_id\x18\x02\x20\x01(\tR\x06taskId\
    \"^\n\x0fHeartbeatStatus\x12\x11\n\rAWAITING_TASK\x10\0\x12\x13\n\x0fPRO\
    CESSING_TASK\x10\x01\x12\x0f\n\x0bHALTED_TASK\x10\x02\x12\x12\n\x0eCANCE\
    LLED_TASK\x10\x03\"\xbf\x02\n\x1bWorkerTaskSubmissionRequest\x12\x1b\n\t\
    worker_id\x18\x01\x20\x01(\tR\x08workerId\x12\x17\n\x07task_id\x18\x02\
    \x20\x01(\tR\x06taskId\x12\x1f\n\x0bdocker_name\x18\x03\x20\x01(\tR\ndoc\
    kerName\x12\x17\n\x07data_in\x18\x04\x20\x03(\x0cR\x06dataIn\x12\x18\n\
    \x07closure\x18\x05\x20\x01(\x0cR\x07closure\x12?\n\x08map_type\x18\x06\
    \x20\x01(\x0e2$.WorkerTaskSubmissionRequest.MapTypeR\x07mapType\"U\n\x07\
    MapType\x12\x17\n\x13SINGLE_IN_MULTI_OUT\x10\0\x12\x18\n\x14SINGLE_IN_SI\
    NGLE_OUT\x10\x01\x12\x17\n\x13MULTI_IN_SINGLE_OUT\x10\x02\"\xe2\x01\n\
    \x15WorkerFinishedRequest\x12\x1b\n\tworker_id\x18\x01\x20\x01(\tR\x08wo\
    rkerId\x12\x17\n\x07task_id\x18\x02\x20\x01(\tR\x06taskId\x12?\n\x06stat\
    us\x18\x03\x20\x01(\x0e2'.WorkerFinishedRequest.WorkerTaskStatusR\x06sta\
    tus\x12\x19\n\x08data_out\x18\x04\x20\x03(\x0cR\x07dataOut\"7\n\x10Worke\
    rTaskStatus\x12\x11\n\rTASK_FINISHED\x10\0\x12\x10\n\x0cTASK_ERRORED\x10\
    \x01\"G\n\x16WorkerFinishedResponse\x12-\n\x12response_processed\x18\x01\
    \x20\x01(\x08R\x11responseProcessed\"<\n\x1dWorkerTaskCancellationReques\
    t\x12\x1b\n\tworker_id\x18\x01\x20\x01(\tR\x08workerId\"}\n\x10Consensus\
    Request\x120\n\x06action\x18\x01\x20\x01(\x0e2\x18.ConsensusRequest.Acti\
    onR\x06action\"7\n\x06Action\x12\x0e\n\nSET_ACTIVE\x10\0\x12\x0f\n\x0bSE\
    T_PASSIVE\x10\x01\x12\x0c\n\x08SHUTDOWN\x10\x02\"\x13\n\x11ConsensusResp\
    onse\"\xbd\x02\n\x13SingleWorkerMessage\x12I\n\x12connection_request\x18\
    \x01\x20\x01(\x0b2\x18.WorkerConnectionRequestH\0R\x11connectionRequest\
    \x12I\n\x12heartbeat_response\x18\x02\x20\x01(\x0b2\x18.WorkerHeartbeatR\
    esponseH\0R\x11heartbeatResponse\x12C\n\x10finished_request\x18\x03\x20\
    \x01(\x0b2\x16.WorkerFinishedRequestH\0R\x0ffinishedRequest\x12@\n\x11co\
    nsensus_request\x18\x04\x20\x01(\x0b2\x11.ConsensusRequestH\0R\x10consen\
    susRequestB\t\n\x07message\"\xe7\x03\n\x13SingleServerMessage\x12L\n\x13\
    connection_response\x18\x01\x20\x01(\x0b2\x19.WorkerConnectionResponseH\
    \0R\x12connectionResponse\x12F\n\x11heartbeat_request\x18\x02\x20\x01(\
    \x0b2\x17.WorkerHeartbeatRequestH\0R\x10heartbeatRequest\x12M\n\x12submi\
    ssion_request\x18\x03\x20\x01(\x0b2\x1c.WorkerTaskSubmissionRequestH\0R\
    \x11submissionRequest\x12F\n\x11finished_response\x18\x04\x20\x01(\x0b2\
    \x17.WorkerFinishedResponseH\0R\x10finishedResponse\x12S\n\x14cancellati\
    on_request\x18\x05\x20\x01(\x0b2\x1e.WorkerTaskCancellationRequestH\0R\
    \x13cancellationRequest\x12C\n\x12consensus_response\x18\x06\x20\x01(\
    \x0b2\x12.ConsensusResponseH\0R\x11consensusResponseB\t\n\x07messageb\
    \x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
